#### **007 Lecture 03.2（Compile v. Interpret）**  
这段讲“**编译** vs **解释**”：有些语言是编译型、有些解释型，也有像 **Java** 这种“两边都有”的；并且用它们来对比程序从源码到能跑起来的大致流程。

#### 017 Lecture 05.3（Memory Locations）
这段讲程序的内存大概怎么分区（哪些东西大概在 stack/heap/其他区域），帮助你把“变量到底住哪儿”这件事想清楚。 

#### 018 Lecture 05.4（Memory Management）
这段讲堆内存管理的一些核心概念：比如 free list、碎片（fragmentation）、以及分配策略（first fit / next fit / best fit）这些取舍。

#### 025 - Lecture 06.5 - Floating Point: Floating Point Discussion
这一节主要在提醒你浮点计算的“坑”：
浮点加法不满足结合律：同样三个数，括号位置不同（先加谁）结果可能不同，因为位数有限，特别大和特别小的数不能同时“都保真”。
然后他定义了一组常用词：
precision（精度）：你用了多少 bits；
accuracy（准确度）：你存下来的值离真实值有多近（精度高不代表一定更准确）。
最后讲 rounding（舍入）：硬件通常会多留一些“舍入位”，并且存在不同舍入模式（比如向 +∞、向 -∞、向 0 截断、或更“无偏”的方式）。

#### 039 - Lecture 10.2：寄存器约定（calling convention）：哪些是“必须保住”的，哪些是“我随便用”的
这节讲嵌套函数调用时最关键的规则：不然大家会互相覆盖寄存器。
核心点：
main 调 function1，function1 再调 function2，这时 ra（x1）会被第二次调用覆盖，所以必须有规则来保存。
于是寄存器被分成两类：
saved（保留类）：调用后应该保持不变（比如 s0–s11）。如果被调用者要用这些寄存器，它就必须先保存、用完再恢复。
temporary/volatile（临时类）：调用后可能会变（比如 t0–t6、a0–a7、ra）。如果调用者想保住这些值，调用者自己要先存起来。
一句话：
s 寄存器由“被调用者”负责还原；t/a/ra 由“调用者”自己负责保命。

#### 040 - Lecture 10.3：过程里的“内存分配”：栈帧（stack frame）长什么样 + C 的 stack/heap/static 在 RISC-V 内存里怎么摆
这节把 C 里你学过的“内存三块”跟 RISC-V 对上：
static（全局/静态）
heap（malloc 的）
stack（函数调用的）
核心点：
函数调用时，栈上会分配一个 stack frame（也叫 procedure frame / activation record）：里面会放返回地址、需要保存的寄存器、还有放不进寄存器的局部变量。
讲了嵌套调用例子：为了不让 ra、以及某些参数寄存器被覆盖，需要把它们先压栈保存，函数调用回来再取回。
讲了 RV32 下的一张“内存地图”：程序（text）在底部附近；其上是静态数据；heap 往上长；stack 在顶上往下长；heap 和 stack 撞上就没内存了。