## UWB

#### 工作原理

<img src="C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20250910101541265.png" alt="image-20250910101541265" style="zoom: 33%;" />
<!--ID: 1764664440013-->


#### 优点

<img src="C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20250910101624009.png" alt="image-20250910101624009" style="zoom: 33%;" />
<!--ID: 1764664440016-->




#### 相关参数

- **同步头（SHR）**：SHR = 前导码 + SFD
- **前导码（Preamble）**：前导码的作用是让接收机进行粗同步，锁定信号，就像在嘈杂的房间里听到有人开始持续地吹口哨，你知道他在那，但不知道他什么时候要开始说话。
- **帧起始分隔符SFD**：SFD 是 UWB 数据帧中的一个**特定字段**，它位于前导码 之后，**物理层帧头（PHR）** 之前。**SFD** 的作用则是**精确地标记有效数据开始的瞬间**。当接收机检测到这个已知的、特殊的SFD序列时，它就知道接下来的比特就是真正的数据（PHR和PSDU）了。**生成精确的时间戳**：因为SFD的序列是已知的，接收机可以通过相关算法**极其精确地确定SFD结束的时刻**。这个时刻被用作计算飞行时间（ToF）的关键时间戳之一，直接决定了测距和定位的精度。
- **下物理层帧头(PHR)传输速率**：**PHR** 是加在 PSDU 数据载荷前面的一个**控制头**。它就像一个信封，包含了如何解析后面数据载荷的关键信息，以**确保接收机能够正确解码后续的数据**。例如：数据载荷的长度(PSDU有多长)数据速率是否使用了加扰时间戳序列（STS）等。
- **加扰时间戳序列（STS）段数和长度**：**STS** 是一段特殊的、随机化的脉冲序列，被插入到UWB帧中（通常在前导码之后）。用于增强安全性
- **物理层服务数据单元(PSDU)数据速率**：物理层从上层（MAC层）接收到的、需要被发送的**实际数据载荷**。它包含了真正要传输的信息，比如传感器读数、控制命令等。**PSDU数据速率** 就是指这个实际数据载荷部分的**传输速率**。
- **脉冲重复频率（PRF）**：每秒内发射的UWB脉冲的**数量**
- **基本脉冲重复频率(BPRF)与高脉冲重复频率(HPRF)**：UWB 系统的两种基本工作模式，核心区别在于**脉冲的密度**。BPRF脉冲密度低，每秒发射的脉冲数量较少，脉冲间隔较大，通讯可靠性高，覆盖距离大，数据速率低，功耗小。HPRF脉冲密度高，每秒发射的脉冲数量多，脉冲间隔较小，测距精度高，抗多径干扰能力强。
<!--ID: 1764664440020-->


#### 帧格式

![image-20251026172413707](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251026172413707.png)
<!--ID: 1764664440023-->


- SP0（标准帧）:
  - 结构：SHR+PHR+PSDU
  - 特点：最基础的帧格式，无安全扩展功能。前导码仅用于**帧同步和信道估计**。**无加密或防中继攻击能力**。
- SP1（带STS的安全帧）:
  - 结构：SHR+PHR+STS+PSDU
  - 特点：STS 是一个动态生成的加密序列，用于防止**中继攻击** 和**信号重放攻击**。STS 提供高精度的到达时间戳（ToA），提升测距/定位精度。

- SP2（带长STS的安全帧）:
  - 结构：SHR+PHR+长STS+PSDU
  - 特点：更长的 STS 增加破解难度。长序列提升在多径环境下的鲁棒性。更多符号可提高时间戳分辨率。

## 无线信道

信道冲激响应(CIR)
<!--ID: 1764664440027-->


信道频率响应(CFR)

信道状态信息(CSI)

CSI与CFR一样，都从频域描述信道对传输信号的影响，他们的差异在于，CFR作为一般化的参数可以描述任意频率处的信道影响，而CSI通常用于OFDM系统中描述各个子信道的信道属性，即信道增益矩阵H（有时也称为信道矩阵，信道衰落矩阵）中每个元素的值。假设发送端装备M根天线，接收端装备N根天线，通信时使用K个子载波，则每次采样得到CSI矩阵的元素数量为M×N×K，每个元素以复数形式a~i~e^−jθi^出现，对应每个子载波的幅度和相位。CSI可以使通信系统适应当前的信道条件，在无线通信系统中为高可靠性高速率的通信提供了保障。CSI可以看作CFR的一种离散采样的形式，采样的频率点为OFDM对应的不同载波频率。

### 信道状态估计

由于无线环境数复杂多变，信号传播到达接收端时，其幅度、相位和频率都会发生很大的改变。因此，为了尽可能恢复出原始信号，我们需要进行信道估计和信道均衡。一个良好的估计和均衡算法对于接收端的性能来说至关重要，决定了信号能否最终被解码出来。
<!--ID: 1764664440031-->


**盲估计**：无需借助导频符号，也不占用频谱资源，只利用接收信号本身固有的特征，来获取信道信息。实际上，在具体使用时，因为盲信道估计计算量复杂，收敛较慢，不适合现实的实时交互通信系统。

半盲估计：半盲信道估计可以借鉴少量导频信号的频率响应来进行信道估计，因此，其性能要好于盲信道估计。但半盲估计通常假设参考的导频信号不对数据传输造成额外影响，训练序列长度受限，因此可能出现相位模糊（基于子空间的方法）、误差传播（如判决反馈类方法）、收敛慢或陷入局部极小等问题，这在一定程度上限制了它的实用性。

非盲估计：使用一段特殊设计的导频信号来辅助信道估计，基于导频辅助的非盲信道估计算法可以分为两个部分：一是导频位置处的信道估计算法；二是非导频位置处的插值算法。非盲估计是目前通信系统常用的信道估计方式。

### 路径损耗

**视距(Line-Of-Sight, LOS)信道**：信号经过自由空间到达距离d处的接收机，发射机和接收机之间没有任何障碍物，信号沿直线传播。
<!--ID: 1764664440034-->


自由空间路径损耗使接收信号相对于发送信号引入了一个复数因子, 产生接收信号：
$$
\begin{align*}
r(t) = Re \left\{ \frac{\lambda \sqrt{G_l} e^{-j 2 \pi d / \lambda}}{4 \pi d} \cdot u(t) e^{j 2 \pi f_c t} \right\}
\end{align*}
$$
式中 $\sqrt{G_1}$ 是在视距方向上发射天线和接收天线的增益之积，$ e^{-j2\pi d/\lambda} $是由传播距离$d$引起相移。
设发射信号$s(t)$的功率为$P_t$，由接收信号$r(t)$的表达式可得到接收功率和发射功率的比为：
$$
\begin{align*}
\frac{P_r}{P_t} = \left( \frac{\sqrt{G_l} \lambda}{4\pi d} \right)^2
\end{align*}
$$


### 阴影衰落

阴影衰落由发射机和接收机之间的障碍物造成，这些障碍物通过吸收、反射、散射和绕射等方式衰减信号功率，严重时会阻断信号，引起障碍物尺度距离（室外为10m~100m，室内更小）上的功率变化。在移动通信传播环境中，电波在传播路径上遇到起伏的山丘、建筑物、树林等障碍物阻挡，形成电波的阴影区，就会造成信号场强中值的缓慢变化，引起衰落。通常把这种现象称为阴影效应，由此引起的衰落又称为阴影慢衰落。另外，由于气象条件的变化，电波折射系数随时间的平缓变化，使得同一地点接收到的信号场强中值也随时间缓慢地变化。但因为在陆地移动通信中随着时间的慢变化远小于随地形的慢变化，因而常常在工程设计中忽略了随时间的慢变化，而仅考虑随地形的慢变化。它是由于在电波传输路径上受到建筑物或山丘等的阻挡所产生的阴影效应而产生的损耗。它反映了中等范围内数百波长量级接收电平的均值变化而产生的损耗，一般遵从对数正态分布。
<!--ID: 1764664440037-->


造成信号随机衰减的因素，一般包括障碍物的位置、障碍物大小、障碍物材料的介电特性、以及反射面和散射体的变化情况。在实际传输场景中，这些因素一般都是未知的，因此只能用统计模型来表征这种随机衰减，最常用的模型是对数正态阴影模型，它已经被实测数据证实，可以用来建模室外和室内无线传播环境中接收功率的变化。

**对数正态阴影模型**：把发射和接收功率的比值$\psi=P_t/P_r$，假设为一个对数正态分布的随机变量

其中 $\xi = 10 / \ln 10$，$\mu_{\psi_{dB}}$ 是以 $dB$为单位的 $\psi_{dB} = 10 \log_{10} \psi$ 的均值，$\sigma_{\psi_{dB}}$ 是以 $dB$为单位的 $\psi_{dB}$ 的标准差。

## 无线测距

### 基于信号强度测距

接收信号强度（RSS）
<!--ID: 1764664440040-->


接收信号强度指示（RSSI）$10lg(RSS/1mW)$

基于信号强度的测距收到环境的影响很大，一般误差会比较大，也很少在真实系统中使用。在实际系统中，较为常用的时基于信号传播时间来进行测距。

### 基于传播时间测距

ToF测距
<!--ID: 1764664440043-->


#### 同步测量方法

原理：在发送端和接收端的精确时间同步前提下，可直接$d=t\times c$。
<!--ID: 1764664440046-->


难点：时钟同步问题。

时钟同步协议：NTP、GPS同步。

现有的时间同步方法在实际使用中仍存在较大的局限性。

- NTP协议主要针对静态网络，并且需要频繁交换消息来不断校准时钟频率偏移带来的误差。此外，NTP协议毫秒级的精度无法满足高精度测距等应用场景的需求。

- GPS能达到纳秒级精度的同步，但GPS受环境遮挡影响大，只适用于室外空旷无遮挡的环境，无法适用于室内低功耗物联网节点。

#### 信号反射实现

##### 全双工

令测距对象作为反射体，直接反射传输的信号。这种方法要求反射体具有一定的体积，并且收发机能在全双工模式工作，即发送信号的同时能接收来自目标对象反射的信号。
<!--ID: 1764664440050-->


**FMCW**：一种在高精度雷达测距中使用的技术,FMCW是频率随着时间线性增长的信号。
$$
R(t) = \cos(2\pi f \min t + \pi (B/T) t^2 )​
$$

$$
\begin{align*}
d = \frac{cT}{2B} \Delta f
\end{align*}
$$

<img src="C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20250910110011560.png" alt="image-20250910110011560" style="zoom:50%;" />

FMCW雷达在扫频周期内发射频率变化的连续波，发射出去的信号被物体反射后的回波与发射信号叠加在一起被接收到。实际收到的信号会呈现上图的特点，反射信号与发射信号存在着时间差。这个时间差在实际系统中不太好直接精确地测量出来。为了解决这一问题，这个时间差可以转化为对应的频率差，通过测量频率差可以获得目标与雷达之间的距离信息，这也是FMCW好用的主要原因。

差频信号频率较低，一般为KHz，因此硬件处理相对简单、适合数据采集并进行数字信号处理。FMCW雷达具有容易实现、结构相对简单、尺寸小、重量轻以及成本低等优点，有广泛的应用前景。

##### 半双工

利用两个设备分别作为发送端和接收端：发送端于时刻t0发送信号，接收端收到信号后，等待时间Δt后返回同样的波，发送端记录收到回复的时刻t1，从而得到距离：d=(v(t1−t0−Δt))/2。这种方法既不要求接收端和发送端时钟同步，也不需要设备具有全双工功能。
<!--ID: 1764664440054-->


难点：两个设备之间实际上通过了数据交换实现了同步的效果。但实际实现时，由于设备软硬件调度、延迟等不确定因素，接收端很难控制等待时间恰好为Δt，很难做到精准的时间控制，因此实际测得的距离也存在较大误差。

单边双向测距

<img src="C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20250910110402481.png" alt="image-20250910110402481" style="zoom: 50%;" />

双边双向测距（TWR）

<img src="C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20250910110428962.png" alt="image-20250910110428962" style="zoom:50%;" />

#### 波速差实现

如果可以利用两种不同的信号的话，两种信号之间的波速差也可以被用来作为测距。
<!--ID: 1764664440057-->


我们可以令发送端同时发送一道电磁波和声波，然后在接收端记录电磁波的到达时刻tr和声波的到达时刻ts。则根据这两个不同的到达时刻，可以计算出发送端与接收端之间的距离
$$
\begin{align*}
d = \frac{v_r \times v_s \times (t_s - t_r)}{v_r - v_s}
\end{align*}
$$


## 无线定位

### 三边定位

<img src="C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20250910124031455.png" alt="image-20250910124031455" style="zoom:50%;" />
<!--ID: 1764664440060-->




### TDOA定位

**标签(Tag)**：待测距、定位的目标
<!--ID: 1764664440063-->


**基站(Anchor)**：位置已知的节点、设备统称

TDOA定位算法又称到达时间差定位，顾名思义，就是利用无线信号到达不同基站的时间差确定目标标签的位置。设标签信号到达不同基站的时间差为Δt，乘上信号传输的速度v，就可以求出无线信号到达不同基站的路程差Δd。给定两个基站，如果知道标签到两个基站的里程差为Δd，就可以推算出标签可能在以两个基站为焦点的双曲线上。在此基础上，我们就可以利用几何知识(即双曲线)求解出目标的位置。

### PDOA定位

<img src="C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20250910161421180.png" alt="image-20250910161421180" style="zoom:33%;" />
<!--ID: 1764664440066-->


根据相位差计算得到p，根据测距原理得到r，根据下列公式实现定位：
$$
\begin{align*}
x &= \left( r - \frac{p}{2} \right) \frac{p}{d} + \frac{d}{2} \quad \quad y \approx \pm (r - \frac{p}{2}) \sqrt{1 - \left( \frac{p}{d} \right)^2}
\end{align*}
$$
**如何测量相位差**：

<img src="C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20250910164348072.png" alt="image-20250910164348072" style="zoom:33%;" />

### AOA定位

#### 获取到达角

##### 多信号分类算法（MUSIC）

一种基于子空间分解的高分辨率波达方向（DOA）估计方法。其基本思想是利用接收信号协方差矩阵的特征分解，将观测空间划分为信号子空间和噪声子空间，并通过这两个子空间的正交性构造空间谱函数，从而实现对信号参数的精确估计。
<!--ID: 1764664440070-->


考虑一个由 *N*个阵元组成的等距线性阵列，阵元间距为 *d*，信号波长为 *λ*。假设空间中存在 *r*个远场信源，则阵列接收信号可表示为：
$$
\begin{align*}
X(t) = \sum_{i=1}^{r} s_i(t) \cdot a(\theta_i) + N(t)
\end{align*}
$$
 $s_i(t)$ 为第 $i$ 个倍源的信号

$\theta_i$ 为第 $i$ 个信号的入射角度

$a(\theta_i)$ 为对应的导向矢量（steering vector），定义为：
$$
$a(\theta_i) = \left[ 1, e^{j \frac{2\pi d \sin \theta_i}{\lambda}}, \ldots, e^{j \frac{2\pi (N-1) d \sin \theta_i}{\lambda}} \right]^T
$$
N(t)为加性噪声

矩阵形式：
$$
\begin{align*}
X(t) = A S(t) + N(t)
\end{align*}
$$
$A = [a(\theta_1), a(\theta_2), \ldots, a(\theta_r)]$ 为导向矩阵

$\begin{align*}
S(t) = [s_1(t), s_2(t), \ldots, s_r(t)]^T
\end{align*}$为信号向量。

接收信号的协方差矩阵为：
$$
\begin{align*}
R_X = E \left[ X X^H \right]
\end{align*}
$$
假设噪声为零均值白噪声，且与信号不相关，则：
$$
\begin{align*}
R_X = AR_S A^H + R_N = AR_S A^H + \sigma^2 I
\end{align*}
$$
 $R_S = E[SS^H]$ 为信号协方差矩阵

$R_N = \sigma^2 I  $ 为噪声协方差矩阵，$\sigma^2$ 为噪声功率。

 $R_X$ 进行特征值分解:

- 若不存在噪声（ $\sigma^2 = 0$），且 $A$ 满列秩 (需 $N > r$ 且入射角互异），则 $AR_SA^H$ 有 $r$ 个正特征值和 $N-r$ 个零特征值。

- 存在噪声时，$R_X$ 有 $N$ 个正特征值，其中前 $r$ 个大特征值对应值号分量，剩余 $N-r$ 个小特征值等于 $\sigma^2$，对应噪声分量。

 $\lambda_1 \geq \lambda_2 \geq \ldots \geq \lambda_N$ 为 $R_X$ 的特征值，对应特征向量为 $v_1, v_2, \ldots, v_N$。则：

- 前 $r$ 个特征向量张成信号子空间，

- 后 $N-r$ 个特征向量张成噪声子空间，记为：

$$
\begin{align*}
E_n = [v_{r+1}, v_{r+2}, \ldots, v_N]
\end{align*}
$$

由于噪声子空间与信号导向矢量正交，即：
$$
\begin{align*}
A^H E_n = 0
\end{align*}
$$
MUSIC 算法通过构造空间谱函数：
$$
\begin{align*}
P_{\text{mu}}(\theta) = \frac{1}{a^H(\theta) E_n E_n^H a(\theta)} = \frac{1}{\|E_n^H a(\theta)\|^2}
\end{align*}
$$

在角度范围 $\theta$ 内进行谱轴搜索，使 $P_{\text{mu}}(\theta)$ 取得极大值的角度即为值源的估计方向。



**理解**

`X`是一个向量，表示某个时刻所有天线的接收数据。

`E[·]`是求期望（Expectation）。在实际计算中，我们通常用**时间平均**来近似这个期望值。假设我们采集了 `L`个时间快照（Snapshots），那么协方差矩阵的估计值为
$$
\begin{align*}
R \approx \frac{1}{L} \sum_{i=1}^L X(i) X^H(i)
\end{align*}
$$
协方差矩阵 `R`是一个方阵，其元素揭示了不同天线接收信号之间的相互关系。

**主对角线上的元素** `R_{ii}`：是第 `i`个天线接收信号的**功率**（方差）。它代表了该天线接收到的总能量（信号能量 + 噪声能量）。

**非对角线上的元素** `R_{ij} (i ≠ j)`：是第 `i`个天线和第 `j`个天线接收信号之间的**协方差**。它衡量了这两个信号之间的相似性和相位关系。

#### 波束成形算法

##### 基于延迟求和的波束成形算法

假设第i个天线接收到的信号为xi(t)，对信号的到达角度θ进行遍历，将不同天线接收到的信号添加与到达角度对应的时延τi(θ)后进行求和，得到信号 ：
$$
x\left(\theta\right)=\sum_{i=1}^{n}{x_i(t-\tau_i\left(\theta\right))}
$$
比较求和得到的信号的强度大小，使求和得到的信号强度最大的方向即为信号的到达方向，即 $$ \theta_{AOA}=\text{argmax}_{\theta}{x(\theta)} $$ 
<!--ID: 1764664440073-->


##### 基于SRP的波束成形方法

### 优智联板

![image-20251026132254446](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251026132254446.png)
<!--ID: 1764664440076-->


![image-20251026131932865](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251026131932865.png)



核心结构体

~~~c
static radar_cfg  s_radar_confg = 
{
    .pulse_type = 1,    //发射脉冲类型
    .tx_power_level = 11,    //发射功率 11级别
    .rx_gain_level = 14,    
	  .preamble_length = 4,//前导码长度 0:64   1:128   2:256   3:512    4:1024     5:2048
    .fp_threshold = 400,    //第一径信号强度
    .cir_tap = Bins,	//CIR采样点数
    .frame_interval = 50 * 1000,	//采样间隔
    .acc_Threshold = 400,	//累积能量门限
    .win_leftLen = 0,	//CIR左侧数据窗口长度
    .win_startshift = 2,	//窗口起始偏移
    .cir_type = 1,	//是否进行相位补偿
    .timeout  = 1500,	//超时时间us
    .radar_handler = user_radar_cbk   //if use of pc tool, here must be NULL	数据处理回调函数
};
~~~



#### pulse_type

~~~
// TX Pulse Type
//zn_single_radar中如果Pulse Type为0将0x0824第30位置0
if(g_radar_confg.pulse_type == 0){
	uint32_t regTmp = zn_read_32bit_reg(UWB_BASE_ADDR + 0x0824);
	uint8_t  regh1 = (regTmp >> 31) & 0x1;
	regh1 = ( regh1 << 1 ) + g_radar_confg.pulse_type;
	regTmp = ( regh1 << 30 ) + ( regTmp & 0x3FFFFFFF);
	zn_write_32bit_reg(UWB_BASE_ADDR + 0x0824, regTmp);
}
~~~
<!--ID: 1764664440080-->


#### tx_power_level

~~~
zn_pa_set(g_radar_confg.tx_power_level);
~~~
<!--ID: 1764664440084-->


#### rx_gain_level

~~~c
uint8_t     g_rxGainTable[] = {0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x17,0x1F,0x27,0x2F};
if(g_radar_confg.rx_gain_level > 11)
{
    zn_radar_rx1_lna_on();
    rx_gain_level = g_radar_confg.rx_gain_level - 11;
}
else{
    zn_radar_rx1_lna_off();
    rx_gain_level = g_radar_confg.rx_gain_level ;
}
<!--ID: 1764664440086-->


regValue = zn_read_32bit_reg(PRF_MODE_ID);
regValue |= VGA_GAIN_OVRD_BIT_MASK;    //启用手动增益
regValue &= (~VGA_GAIN_REG_BIT_MASK);    //清除原增益值
regValue |= (VGA_GAIN_REG_BIT_MASK ((g_rxGainTable[rx_gain_level]) << VGA_GAIN_REG_BIT_OFFSET));    //添加新增益值
zn_write_32bit_reg(PRF_MODE_ID, regValue);
~~~

#### preamble_length

~~~
uint16_t    g_preambleTable[7] = {1,5,6,7,2,8,3};
// Preamble Length
regValue = zn_read_32bit_reg(TX_PHR_CTRL_ID);
regValue &= (~TX_PHR_CTRL_TXPSR_PE_BIT_MASK);
regValue |= (TX_PHR_CTRL_TXPSR_PE_BIT_MASK & ( (g_preambleTable[g_radar_confg.preamble_length])<< TX_PHR_CTRL_TXPSR_PE_BIT_OFFSET));
zn_write_32bit_reg(TX_PHR_CTRL_ID,regValue);
// 
//  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Need to change the threshold based on the configured preabmle length  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Need to change the frame period based on the configured preabmle length  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
if(g_radar_confg.preamble_length == 0)
{
	zn_write_32bit_reg(UWB_BASE_ADDR + 0x1900, 0x2AFFCFC8);
}
else{
	zn_write_32bit_reg(UWB_BASE_ADDR + 0x1900, 0x2A7FC7D2);
}
~~~
<!--ID: 1764664440089-->


![image-20251026142046412](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251026142046412.png)

#### fp_threshold

~~~c
//计算首径门限。从设定参数值开始，每次测试发射一次信号并检测是否检测到首径，若没有门限阈值减小50，最多测试20次，阈值不小于50
uint32_t  radar_calibrate(uint32_t fpThreshold_Init)
{
	uint8_t  fpCheckIdx = 0;
	uint8_t  fpCheckNum = 20;
	uint32_t fp_threshold = 0;
	
	g_radar_confg.fp_threshold = fpThreshold_Init;
	while(fpCheckIdx < fpCheckNum && g_radar_confg.fp_threshold >= 50 )
	{
		fpCheckIdx++;
		zn_single_radar();
		mdelay(100);
		if(g_fpthreshold_check_flag)
		{
			break;
		}
		g_radar_confg.fp_threshold  -= 50;
	}
    fp_threshold = g_radar_confg.fp_threshold;
	return fp_threshold;
}
~~~
<!--ID: 1764664440091-->


#### frame_interval

~~~
//设置定时器每frame_interval us 触发一次中断
//radar_init()
timer_start(TIMER1,  g_radar_confg.frame_interval);
<!--ID: 1764664440097-->


//每次中断执行一次zn_single_radar
void timer1_irq_proc(void)
{
    if(g_radar_run)
    {
        //g_pingpong_buf.timer_out_index++;
        //send_radar_data();
        zn_single_radar();
        first_frame_send_flag = TRUE;
    }
}
~~~

#### acc_Threshold

~~~
zn_read_cirmemory(void)
{
    
    if((zn_read_32bit_reg(IP_NACC1_ID) >> IP_NACC0_BIT_OFFSET) < g_radar_confg.acc_Threshold)
    {
      return;
    }
~~~
<!--ID: 1764664440101-->


表示**累积的前导码序列符号数量**

![image-20251026144244627](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251026144244627.png)

#### timeout

~~~
zn_single_radar()
	zn_set_rx_timeout(g_radar_confg.timeout);
~~~
<!--ID: 1764664440104-->


#### radar_handler

~~~
zn_read_cirmemory()
	g_radar_confg.radar_handler(g_buffer_f0_I, g_buffer_f0_Q, g_buffer_f1_I, g_buffer_f1_Q );
<!--ID: 1764664440106-->


回调函数调用以下函数，计算距离、pdoa、aoa
breath_detect_aoa_calibration(buffer_I, buffer_Q, buffer_I_1, buffer_Q_1, &ready, &detected);
~~~

切换天线

~~~c
#define ANALOG_ANTENNA_SWITCH_ID                       (UWB_BASE_ADDR + 0x105C)

/*************************************************************************************************************
* Description: This function is switch the antenna switch.
* Input param: ant_state: 
1:pdoa sw froce to rx2 input.
2:pdoa sw force to rxl input
* Output param: None
* Return value: None
*************************************************************************************************************/
void zn_pdoa_antenna_switch(uint8_t ant_state)
{
    uint32_t reg_value = 0;
<!--ID: 1764664440109-->


    reg_value = zn_read_32bit_reg(ANALOG_ANTENNA_SWITCH_ID); // clear bit to 0
    reg_value &= (~PDOA_SW_FORCE_RX1RX2_INPUT_SWITCH_MASK);
    reg_value |= ((ant_state<<PDOA_SW_FORCE_TO_RX2_INPUT_BIT_OFFSET) & PDOA_SW_FORCE_RX1RX2_INPUT_SWITCH_MASK);
    zn_write_32bit_reg(ANALOG_ANTENNA_SWITCH_ID, reg_value);
}
~~~

#### CIA

![image-20251026161538045](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251026161538045.png)
<!--ID: 1764664440112-->


10

![image-20251113155741580](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113155741580.png)

100

![image-20251113155811534](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113155811534.png)

1000

![image-20251113155843461](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113155843461.png)

10000

![image-20251113155938455](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113155938455.png)



15542

![image-20251113160009526](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113160009526.png)



100个点1tar_100cm_0.txt

![image-20251113162738908](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113162738908.png)



100个点1tar_100cm_0_d.txt

![image-20251113162646866](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113162646866.png)



100个点1tar_150cm_0.txt

![image-20251113161351441](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113161351441.png)

100个点1tar_200cm_0.txt

![image-20251113161624300](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113161624300.png)

100个点1tar_200cm_0_d.txt

![image-20251113161553842](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113161553842.png)

100个点1tar_300cm_0.txt(会不会d与非d搞发了)

![image-20251113161703965](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113161703965.png)

100个点1tar_300cm_0_d.txt

![image-20251113161819903](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20251113161819903.png)



1tar_100cm_0.txt

窗长100，滑动10



1tar_200cm_0.txt

window 100 

step 10

不去杂波

对方差进行cfar pfa 0.01

```
num:500
count:388
error:88
```



不去杂波

对方差进行cfar pfa 0.001

```
num:500
count:260
error:18
```



去杂波0.98

对方差进行cfar pfa 0.01

```
num:500
count:405
error:66
```



去杂波0.98

对方差进行cfar pfa 0.001

```
num:500
count:246
error:4
```



去杂波0.98

对幅度进行cfar pfa 0.01

200次、判别63、错判0



去杂波0.98

对幅度进行cfar pfa 0.001

200次、判别0