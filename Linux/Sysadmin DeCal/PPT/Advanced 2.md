> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [chat.zchat.tech](https://chat.zchat.tech/c/691c148d-6fb0-832e-8b1d-e8ca43adfbe7)

> ChatGPT helps you get answers, find inspiration and be more productive. It is free to use and easy to......

**Linux 里的 “软件包（package）” 和“包管理器（package manager，比如 apt）是干什么的，它们怎么工作，为什么这么设计。**

我用特别白话、一步一步帮你把整节课捋一遍。

1. 课一开始讲了啥
----------

*   老师先自我介绍：叫 Daniel，以前是 Berkeley 学生，在 OCF（学校里做服务器、Linux 的社团）当过管理员，也教过这门课。
    
*   这节课的主题：**packages（软件包）**。
    
*   他在一开始就给出一个大纲，大概是：
    
    1.  为什么需要 “软件包” 这种东西？
        
    2.  “软件包” 到底是什么？
        
    3.  包管理的 “理念”：谁来打包、谁来更新、你在信任谁。
        
    4.  实际在 Linux 上，包和仓库是怎么工作的（特别是用 apt）。
        
    5.  怎样添加新的仓库，比如 Docker、backports 这些。
        

2. 没有 “软件包” 的世界有多惨
------------------

老师先说：我们先想象**没有包管理器**，软件是怎么分发的。

*   你写了一个程序，要给别人用：
    
    *   你会打包一堆文件，压成 zip 或 tar.gz，让别人下载。
        
    *   别人解压后，还要自己想办法把文件放到 “正确的位置”。
        
*   问题一堆：
    

1.  **文件放哪儿？**
    
    *   放桌面？
        
    *   放 `/usr/local`？
        
    *   放自己随便建的一个目录？  
        完全没有统一标准，很乱。
        
2.  **更新怎么弄？**
    
    *   你更新了软件，要让所有用户都用新版本。
        
    *   用户要自己去你网站再下一个压缩包，再覆盖一遍。
        
    *   很容易有人还在用旧版本，带着漏洞。
        
3.  **依赖（dependencies）怎么办？**
    
    *   你的程序可能要用别的库、别的程序。
        
    *   用户得自己去找这些 “依赖”，一个个安装。
        
    *   甚至有时候连 “需要什么依赖” 都没人写清楚。
        
4.  **卸载呢？**
    
    *   当初文件都乱放，卸载的时候也很难把所有东西删干净。
        
    *   系统里到处是垃圾文件。
        
5.  **安全问题**
    
    *   用户在网上到处搜 “XXX 下载”，下的是谁做的根本不知道。
        
    *   很容易下到有后门、带病毒的东西。
        

老师说：这种 “从网上随便下一个二进制文件 / 压缩包” 的方式，很**原始（naive）**，现实里还是经常看到，但问题非常多。

3. 什么是 “软件包” 和“仓库”
------------------

所以就有了 **package（软件包）**和** repository（仓库）** 的概念。

*   **一个软件包（package）**：
    
    *   里面包含：
        
        *   这个软件需要的各种文件
            
        *   元数据（metadata）：
            
            *   这个包叫什么名字
                
            *   版本号是多少
                
            *   这个包依赖哪些别的包
                
            *   一些说明信息
                
    *   这样，系统才能知道：
        
        *   要把文件放哪儿
            
        *   要先装哪些依赖
            
        *   将来要怎么升级、卸载
            
*   **仓库（repository）**：
    
    *   可以理解成：**一个大仓库 / 软件超市**。
        
    *   里面放着很多很多包。
        
    *   你的 Linux 发行版（比如 Debian、Ubuntu）默认就配置了几个仓库：
        
        *   主仓库（比如 Debian stable）
            
        *   安全更新仓库（security updates）
            
        *   有时候还有 backports 等。
            
*   **包管理器（apt 等）**：
    
    *   就像 “去超市买东西用的 app”。
        
    *   它知道：
        
        *   有哪些仓库
            
        *   每个仓库里有哪些包
            
    *   你只需要说：我要装 `htop`，它会帮你：
        
        *   找到这个包
            
        *   下载它
            
        *   检查签名和完整性
            
        *   安装到正确的位置
            
        *   顺便把依赖一起装上
            

4. 实际示范：用 apt 安装 htop
---------------------

老师现场演示了一个例子：**安装 htop**（一个看进程和 CPU 使用情况的工具）。

1.  一开始他在终端打 `htop`，系统说：**command not found**，说明没装。
    
2.  然后他输入：
    
    ```
    apt install htop
    ```
    
3.  系统就会：
    
    *   去配置好的仓库里查 “htop” 这个包。
        
    *   找到对应的包，下载下来。
        
    *   检查签名（确认没被篡改）。
        
    *   解压、把文件放到正确目录。
        
4.  安装完成后，他再打 `htop`，这回就能跑起来了。
    

他还顺便提到：

*   以前常用命令是 `apt-get install`，  
    现在一般直接用 `apt install`，因为：
    
    *   `apt` 把好几个旧的子命令（apt-get、apt-cache 等）合并到一起，更方便。
        
    *   在现代系统上 `apt` 是更推荐的命令。
        

5. Linux 包管理的几个大优点
------------------

老师用了不少时间讲 “为什么 Linux 的包管理这么重要”。

**优点 1：自动处理依赖**

*   一个包可以说明：自己依赖哪些包。
    
*   当你装这个包时，包管理器会自动把依赖也装上。
    
*   如果依赖是安全关键的软件，发行版可以给它打补丁、发更新，你只要更新系统就能拿到这些修复。
    

**优点 2：集中更新**

*   Linux 下，大部分软件都是通过发行版的仓库装的。
    
*   你不用每个程序各自更新，只要用一套更新机制（比如 apt）就能：
    
    *   更新系统
        
    *   更新应用
        
    *   更新依赖库
        
*   对比：
    
    *   以前的 Windows / Mac 上，每个软件可能自己带更新器，很乱。
        

**优点 3：卸载干净**

*   包里记录了安装了哪些文件。
    
*   要卸载的时候，包管理器可以一口气把相关的文件都删掉。
    
*   比你自己到处复制文件再乱删要干净得多。
    

**优点 4：方便维护很多机器**

*   对系统管理员（SysAdmin）来说，如果有很多服务器：
    
    *   统一用包管理器，就能比较容易地：
        
        *   安装同一版本
            
        *   统一打安全补丁
            
        *   管理依赖关系
            

6. “理念问题”：你到底在信任谁？
------------------

老师花了一大段讲**安全 & 信任**的问题。

*   在 Linux 里，你主要是**信任发行版和包维护者**：
    
    *   比如在 Debian：
        
        *   软件是开源的。
            
        *   发到仓库里的包，由 “包维护者（maintainer）” 来管理。
            
        *   维护者不一定是软件原作者，而是 “帮你把软件打包到 Debian 里的人”。
            
    *   他们可以：
        
        *   自己审查源码。
            
        *   必要时给软件打补丁（他举了 Firefox 的例子，说 Debian 会自己打补丁）。
            
*   包管理是一个 **“社会系统（social system）”**：
    
    *   你相信：Debian 这群人总体上是认真的、不会乱来。
        
    *   他们用 GPG 签名来保证包没有被篡改：
        
        *   仓库里的包都有签名。
            
        *   apt 只接受那些用 “受信任的密钥” 签过名的包。
            
*   他还拿其他平台来对比：
    
    *   手机上的 App Store / Play Store：  
        你更多是在信任 Apple/Google 审核过的应用。
        
    *   一些系统会弹出权限对话框（比如 “允许用摄像头吗？”）；
        
        *   在 Linux 世界里，很多东西更偏向 “你先信发行版的人”。
            
*   他还简单提到 **sandbox（沙箱）、isolation（隔离）**：
    
    *   意思就是把程序关在一个 “盒子” 里：
        
        *   限制它能访问的东西。
            
        *   防止程序随便读写系统里的其他数据。
            

7. 不同系统的包管理器
------------

老师顺带讲了不同系统的工具：

*   Debian / Ubuntu：**apt**（底下是 dpkg，但课里重点讲 apt）。
    
*   Arch Linux：**pacman**，还有用户自己贡献软件的 **AUR（Arch User Repository）**。
    
*   Red Hat Linux：**yum**，后来还有 **DNF**。
    
*   Fedora 也是用这套。
    
*   Mac 上有 **brew** 这种包管理工具。
    
*   还有其他形式的 “应用商店式” 分发：
    
    *   Linux 上的 **snaps、flatpaks**（桌面 Linux 上的类似 app store 的东西）。
        
    *   Android 上的 **F-Droid**（自由软件 app 商店）。
        
*   不同系统名字不一样，**核心思想都差不多**：
    
    *   有包
        
    *   有仓库
        
    *   有一个包管理器帮你装、升级、卸载
        

8. 仓库 / 软件源是怎么配置和添加的
--------------------

老师讲了 Linux 上仓库位置：

*   像 Debian，会在：
    
    *   `/etc/apt/sources.list`
        
    *   和 `/etc/apt/sources.list.d/` 里写好一堆地址，  
        告诉 apt：去哪几个服务器拉取包列表和包。
        
*   你可以**添加新仓库**，比如：
    
    *   Docker 官方就有自己的仓库。
        
    *   老师说他会简单讲讲 Docker 这个例子。
        

**Docker 官方的安装说明大概是：**

1.  先卸载系统里旧的 Docker 版本。
    
2.  把 Docker 自己的仓库加到你的系统配置里。
    
3.  跑 `apt update`，让系统知道 “现在多了一个新地方可以拿包”。
    
4.  然后用 apt 装 Docker 的包。
    

老师强调：  
一旦你**把某个第三方仓库加进系统**，你就等于说：

> “以后这个地方发的新包，我系统会自动相信并且更新。”

所以这是一个**很大的信任决定**，要小心。

9. backports 的具体例子（以 tmux 为例）
-----------------------------

后面他讲了 **backports 仓库** 的例子。

*   在 Debian 里：
    
    *   Debian stable：版本很稳，但软件版本可能比较旧。
        
    *   backports：为 stable 用户**额外提供一些 “比较新的软件版本”**，但还是针对 stable 编译的。
        

他以 **tmux** 为例：

1.  给系统加上 backports 仓库。
    
2.  跑 `apt update`。
    
3.  用：
    
    ```
    apt policy tmux
    ```
    
    来看：
    
    *   tmux 在 “普通 stable 仓库” 里有一个版本（比如 2.x）。
        
    *   在 backports 里有另一个更高的版本（比如 3.x）。
        
4.  `apt policy` 会显示：
    
    *   每个版本来自哪个仓库。
        
    *   每个仓库的优先级（priority）。
        
    *   哪个版本是 apt 默认会选的（前面有星号）。
        

他解释说：

*   apt 会根据**优先级**决定默认装哪个版本。
    
*   backports 的默认优先级通常比较低，所以系统不会随便把所有东西都换成 backports 版本。
    
*   但你可以明确指定 “我要从 backports 装”。
    

这一段是为了说明：  
**包管理不只是 “装东西” 这么简单，还涉及版本选择、优先级、不同仓库之间的取舍。**

10. 稳定版 vs 滚动发行
---------------

老师还简短比较了一下：

*   像 **Debian stable**：
    
    *   追求很稳。
        
    *   软件版本不一定最新。
        
    *   安全更新会打补丁，但不会随便大版本升级。
        
*   像 **Arch Linux**：
    
    *   是 “rolling release（滚动发行）”：
        
        *   经常更新到比较新的版本。
            
        *   但又尽量保证不要太不稳定。
            

意思就是：不同发行版在 “稳定” 和“新”之间做了不同取舍。

11. 最后总结 & 资源
-------------

课的最后，老师：

*   用一张总览的幻灯片把重点再过了一遍（包、仓库、安全、信任、backports 等）。
    
*   说所有的链接（比如 Docker 文档、Debian 文档等）都放在最后一张 slide 上。
    
*   邀请大家：
    
    *   去看这些链接继续学。
        
    *   有问题可以在课程的聊天频道问他，他会在那边答疑。