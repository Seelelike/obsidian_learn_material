> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [chat.zchat.tech](https://chat.zchat.tech/c/6912b03b-a5bc-832a-8a72-7c478c14034b)

> ChatGPT helps you get answers, find inspiration and be more productive. It is free to use and easy to......

已思考 10s
下面把这段关于 **xv6 的上下文切换（context switching）** 逐条拆开，力求把 “谁在什么栈上、在哪个地址继续执行、为什么需要 scheduler 线程” 说清楚。

* * *

1) 从一个用户进程切到另一个用户进程，实际经历了哪些阶段？
==============================

图 7.1（文中描述）概括了 4 步：

1.  **用户→内核过渡**：  
    由**系统调用**或**中断 / 异常**引发，CPU 跳到当前进程的**内核线程**（也就是该进程的内核栈 + 内核态 PC）执行，例如进入 `usertrap()`。
    
2.  **切到本 CPU 的调度器线程**：  
    当前进程在内核里调用 `yield()` → `sched()`，接着调用 `swtch(&p->context, &cpu->scheduler)`，把 “自己” 的寄存器保存起来，并切换到**本 CPU 的 scheduler 线程**。
    
3.  **调度器挑选新进程并切到它的内核线程**：  
    调度器选中下一个 RUNNABLE 进程 `p2` 后，再次调用  
    `swtch(&cpu->scheduler, &p2->context)`，恢复 `p2` 之前保存的寄存器和栈，回到它**上次停下**的内核位置。
    
4.  **从内核返回到新进程的用户态**：  
    新进程的内核线程最终通过 `trapret`（RISC-V 上是 `sret`）把用户寄存器 / PC 恢复，回到用户空间继续跑。
    

> 关键点：虽然我们说 “从进程 A 切到进程 B”，但真正做切换的是**两个内核线程**（A 的内核线程 ⇄ scheduler 线程 ⇄ B 的内核线程），最后 B 的内核线程再把 B 的用户态恢复出来。

* * *

2) 为什么每个 CPU 都要有**独立的调度器线程**（独立寄存器集 + 独立调度器栈）？
==============================================

调度器不能 “踩在旧进程的内核栈上” 运行。原因：

*   旧进程可能在别的核被唤醒并**被另一个 CPU 运行**；如果两个 CPU 共享同一个内核栈，会造成**数据破坏**（同一块栈被两个核并发使用）。
    
*   因此 xv6 为**每个 CPU** 准备一个 **`cpu->scheduler` 上下文和一个调度器栈**，调度器总是在**自己的栈**上运行，互不干扰，线程安全。
    

* * *

3) `swtch` 到底做了什么？为什么 “不直接保存 PC” 也能回到正确的位置？
===========================================

`s w t c h` 是汇编例程（RISC-V 上在 `kernel/swtch.S`），只做两件事：

*   **保存**当前线程的 **callee-saved** 寄存器到 `old` 指向的 `struct context`：  
    这包含 `ra`（返回地址）、`sp`（栈指针）、以及 `s0`~`s11` 等。
    
    > _说明_：按 ABI，caller-saved 由**调用者**先行压栈；因此 `swtch` 只管 callee-saved，编译器已在调用处处理好 caller-saved。
    
*   **恢复**`new` 指向的 `struct context` 里的寄存器，然后 `ret`：  
    恢复了 `sp` → **切换到新线程的栈**；  
    恢复了 `ra` → `ret` 时**跳回到 “新线程上次调用 `swtch` 的下一条指令”**；  
    所以不需要单独保存 / 恢复 PC，**`ra` 就是 “返回地址寄存器”**，等价于保存了 “要继续执行的代码位置”。
    

> 直观理解：每个线程上次 “把自己挂起” 的地方，都是一次对 `swtch` 的调用；下次恢复它时，把当时存下的 `ra`/`sp`/`s*`装回去，`ret` 就回到了那条调用 `swtch` 的地方，好像 “从 `swtch` 调用返回了一样”，代码自然接着往下跑。

* * *

4) 把调用链走一遍（从旧进程让出 CPU 到回到调度器）
=============================

以 “进程 P 因为 `yield()` 主动让出 CPU” 为例：

1.  用户态触发系统调用 / 时钟中断 → 进入 `usertrap()`；某些情况调用 `yield()`。
    
2.  `yield()` → `sched()`；`sched()` 做一些检查（确保持有自旋锁、设置状态等），然后  
    **`swtch(&p->context, &cpu->scheduler)`**：
    
    *   把**当前内核线程**（P 的内核态）的 `ra/sp/s*` 存到 `p->context`；
        
    *   从 `cpu->scheduler` 里把调度器的上下文装回；
        
    *   `ret` —— **回到上次调度器调用 `swtch` 的地方**，并且**已经使用调度器自己的栈**。
        
3.  现在在调度器代码里（本 CPU 的 `scheduler()` 函数）继续执行：
    
    *   在循环里挑一个 RUNNABLE 进程 Q，标记 RUNNING，设定当前 CPU 归属等；
        
    *   再次调用 **`swtch(&cpu->scheduler, &q->context)`**：  
        _保存_调度器自己的上下文，_恢复_ Q 的内核上下文；  
        `ret` —— **回到 Q 内核线程上次停下的地方**（例如刚从用户态陷入时的内核路径）。
        
4.  Q 内核线程最终通过 `trapret` 把用户寄存器恢复，执行 `sret` 回到 Q 的**用户空间**。
    

> 小结：`sched()` 调用的那次 `swtch` **返回到 `scheduler()`**；  
> `scheduler()` 调用的那次 `swtch` **返回到某个进程的内核线程**。  
> 这解释了原文那句：“当我们跟踪的这次 swtch 返回时，它不是回到 `sched`，而是回到 `scheduler`，并且栈指针已经在当前 CPU 的调度器栈上。”

* * *

5) 上下文（`struct context`）长什么样？它放在哪？
==================================

*   结构定义在 `kernel/proc.h`：
    
    ```
    struct context {
      uint64 ra;
      uint64 sp;
      uint64 s0; … uint64 s11;
    };
    
    
    ```
    
*   **每个进程**有一个 `struct proc`，里面含有一个 `struct context p->context`，用于**进程内核线程**的保存与恢复。
    
*   **每个 CPU** 有一个 `struct cpu`，里面含有一个 `struct context cpu->scheduler`，表示本 CPU 的**调度器线程**的上下文。
    

* * *

6) 细节与常见疑惑
==========

*   **为什么 `swtch` 不保存 / 恢复所有寄存器？**  
    依据函数调用约定：caller-saved（如 `t*`, `a*`）由调用方在进入 `swtch` 前已经压栈，`swtch` 只需处理 callee-saved 与 `sp/ra`。这让保存最小化，切换更快。
    
*   **为什么切换后 “自动换栈”？**  
    因为 `swtch` 恢复了新的 `sp`，于是函数返回后就已经在**新线程的栈**上运行了。
    
*   **“返回到之前调用 `swtch` 的下一条指令” 是什么意思？**  
    thread A 之前在某处调用了 `swtch(old=&A,new=&S)` 并挂起；现在从 `new=&A` 恢复，`swtch` 把当时保存的 `ra` 装回，`ret` 就回到当年的那次 `swtch` 之后，像 “从 `swtch` 返回” 一样继续执行。
    

* * *

7) 一句话总括
========

> __上下文切换 = 保存当前内核线程的（ra/sp/s_）→ 恢复目标线程的（ra/sp/s_）→ `ret` 回到目标线程上次停下处 **；  
> 调度器之所以安全，是因为**每个 CPU 有独立的调度器线程与栈**，永远不踩任何进程的内核栈。

