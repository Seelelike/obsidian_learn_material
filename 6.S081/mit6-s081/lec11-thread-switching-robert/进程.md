> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [chat.zchat.tech](https://chat.zchat.tech/c/6912b03b-a5bc-832a-8a72-7c478c14034b)

> ChatGPT helps you get answers, find inspiration and be more productive. It is free to use and easy to......

很好，这段话在强调 **调度代码维护的一组 “进程不变量”（invariants）**，以及为什么 **`p->lock`** 要在 ** 跨线程（yield→scheduler）** 之间 “接力” 持有，从而保证在 **RUNNING ↔ RUNNABLE** 的过渡过程中不会出错。再配合 7.4 的 **`mycpu()` / `myproc()`**，你就能把 “当前 CPU、当前进程、寄存器位置、锁与状态” 的关系串起来。下面逐块拆解。

* * *
[[book#^blcoxl40sj|不变量]]
一、两条核心不变量（必须一直成立，除非正受锁保护进行状态转换）
===============================

不变量 A：当进程是 **RUNNING** 时
------------------------

> 定时器中断里的 `yield()` 必须可以**安全地**把它切走。

这要求：

1.  **真实 CPU 寄存器**里装的就是该进程的寄存器值  
    （也就是：还没有被 `swtch` 搬走到 `p->context`），
    
2.  当前 CPU 的 `c->proc` 必须指向这个进程  
    （调度器、trap、`yield()` 都依赖它找到 “谁在跑”）。
    

> 直观理解：RUNNING = “真的在 CPU 上跑”。  
> 所以 “寄存器在 CPU 里”，“c->proc 指向它” 这两件事必须为真，  
> 这样**随时**被时钟打断，`yield()` 都能把它妥善存起来。

* * *

不变量 B：当进程是 **RUNNABLE** 时
-------------------------

> 任意空闲 CPU 的调度器都应该能**安全地**把它拿起来跑。

这要求：

1.  **`p->context`** 里保存了该进程的寄存器（意味着：寄存器**不在**真实 CPU 上），
    
2.  **没有任何 CPU** 正在使用这个进程的**内核栈**，
    
3.  **没有任何 CPU 的 `c->proc`** 指向这个进程。
    

> 直观理解：RUNNABLE = “停在路边，随时可上车”。  
> 要上车安全，得满足：寄存器已在 “上下文包” 里，没人还在用它的栈，也没人声称自己在开它（`c->proc` 不指它）。

* * *

二、为什么 “拿着 `p->lock` 的时候，上述不变量**经常不成立**”？
========================================

因为**状态转换**本身会短暂破坏不变量。例如把 RUNNING 改成 RUNNABLE 的过程中：

*   你先把 `p->state = RUNNABLE`（已经不再是 RUNNING 的不变量 A），
    
*   但此时还没 `swtch` 到调度器、还在**用它自己的栈**、CPU 寄存器还装着它……（又不满足 RUNNABLE 的不变量 B）。
    

> 这段 “既不是 A，也不是 B” 的**中间态**，就必须靠 `p->lock` 保护——  
> 只有拿着锁才能安全地穿过这段 “危险地带”，直到把不变量重新修好。

* * *

三、为什么 **`p->lock` 会在一个线程加锁、另一个线程解锁**？
=====================================

### 例 1：**从 RUNNING → RUNNABLE**（在进程的 `yield()` 路径）

时间线（只关注要点）：
<!--ID: 1764664441471-->


1.  进程 P（在 CPU0 上）进入内核，决定让出 CPU：  
    `yield()`：**acquire(p->lock)**，把 `p->state` 改为 **RUNNABLE**。
    
    > 这时不变量 A 已经被破坏（不再是 RUNNING），  
    > 不变量 B 也没建立（寄存器和栈还在用）。
    
2.  `sched()` → `swtch(&p->context, &cpu->scheduler)`
    
    *   `swtch` 把 P 的 **callee-saved** 寄存器搬到 `p->context`；
        
    *   切到**调度器的栈**与上下文；
        
    *   **注意：`p->lock` 仍然持有**（锁在 “跨线程传递”）。
        
3.  回到调度器 `scheduler()`（在 CPU0 的调度器栈上），它把 `c->proc` 清空：
    
    *   现在满足了 RUNNABLE 的三件事：  
        寄存器在 `p->context`、没人用它的栈、`c->proc` 不指它。
        
    *   **此时才是释放 `p->lock` 的最早正确时机**（invariants restored）。
        

> 如果不这么做，可能在第 1/2 步时，另一个 CPU1 看到它是 RUNNABLE 就来跑它，  
> 但 P 还在用自己内核栈 / 寄存器没存好——会出现**两个 CPU 共用同一内核栈**的灾难。

### 例 2：**从 RUNNABLE → RUNNING**（在调度器挑中它时）

1.  调度器拿到 RUNNABLE 的进程 Q，**acquire(p->lock)**，  
    标记 `p->state = RUNNING`，设置 `c->proc = p`，`swtch(&cpu->scheduler, &p->context)`；
    
2.  `swtch` 恢复 Q 的内核寄存器与栈，回到它当时停下来的地方（比如 `yield()` 之后）。
    
3.  **等到它已经 “完全跑起来”**（也就是在它的内核线程里，例如 `yield()` 返回后），才是释放 `p->lock` 的正确点。
    
    > 因为 RUNNING 不变量 A 要求 “寄存器在 CPU 里、`c->proc` 指它”。  
    > 在切换完成前这些还没完全到位，不能提前放锁。
    
<!--ID: 1764664441474-->


**结论**：  
`p->lock` 的**持有区间跨越 `swtch`**，并且**加锁处和解锁处往往不是同一个函数 / 线程**。  
这种 “锁接力” 是为了保证 **A/B 两个不变量**在状态过渡期间不会被别的 CPU 观察到 “半成品”。

* * *

四、把 “谁来切、切到哪” 看成**协程（coroutines）**
==================================

在 xv6 里，线程切换总在**固定的两个位置**来回：

*   `scheduler()` 调 `swtch` → 切到某个进程
    
*   进程里 `sched()` 调 `swtch` → 切回 `scheduler()`  
    因此你会看到切换的代码行号在两个点之间反复出现，像协程互相 “让出 / 恢复”。
    

有个**唯一的例外**：新建进程第一次被调度时，调度器切到它会 “返回到 `forkret`”，用来**释放 `p->lock`** 并完成首次进入用户态前的收尾。

* * *

五、`mycpu()` 与 `myproc()`（7.4）如何保证 “拿到的是**当前** CPU / 进程”？
========================================================

*   **`mycpu()`**：返回**当前核**的 `struct cpu*`。  
    实现要点：
    
    *   通过 RISC-V 的 `tp` 寄存器保存本核的索引或指针；
        
    *   调用时通常**关中断**（或在持锁路径中），避免在获取指针的刹那被抢占到别的核；
        
    *   因为如果中间被切走 / 迁核，拿到的就不是 “当前 CPU” 的结构了。
        
*   **`myproc()`**：先 `mycpu()` 拿到 `c`，再读 `c->proc`。  
    约束：
    
    *   只能在**保证不会被切换走**的条件下调用（例如关中断或持有合适的锁）；
        
    *   否则 `c->proc` 可能在你读的时候被调度器改了，得不到一致视图。
        

> 这两个函数是 “不变量 A/B 的读入口”。  
> `c->proc` 和 “关中断 / 持锁” 的配合，保证你看到的 “当前进程 / 当前 CPU” 与寄存器 / 栈的实际关系是**一致**的。

* * *

六、把整个故事连起来（极简心智图）
=================

```
struct context {
  uint64 ra;
  uint64 sp;
  uint64 s0; … uint64 s11;
};
```

* * *

七、常见疑惑一网打尽
==========

*   **为什么必须让 `scheduler` 在自己的栈上运行？**  
    防止 “旧进程还在用它的内核栈时，就被别的核抢去运行”，造成**同一栈双核并发**。
    
*   **为什么 RUNNABLE 要求 “没人用它的栈、没人把 `c->proc` 指向它”？**  
    因为这意味着 “它是**静态的快照**（寄存器都在 `p->context`），任何 CPU 拿到它都能安全恢复，不会撞栈 / 撞指针”。
    
*   **为什么锁要跨 `swtch`？**  
    因为中间态 “非 A 非 B” 很脆弱，只能在**持锁**时短暂存在；  
    直到 `scheduler` 或进程把另一端的状态收尾到位（恢复 A 或 B），才放锁。
    

* * *

如果你愿意，我可以给你配一段精简的伪代码（`yield/sched/scheduler`/`mycpu/myproc`）标注 “持锁 / 关中断 / 不变量” 的注释版，或者画一张 “状态机 + 锁范围” 图，帮助你在代码里定位这些关键点。