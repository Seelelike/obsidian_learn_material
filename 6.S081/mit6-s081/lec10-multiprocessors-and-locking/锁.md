>程序想要提升性能，它不能只依赖单核，必须要依赖于多核。这也意味着，如果应用程序与内核交互的较为紧密，那么操作系统也需要高效的在多个CPU核上运行。
[[10.1-why-lock#^299396]]
>为了确保正确性。当一份共享数据同时被读写时，如果没有锁的话，可能会出现race condition，进而导致程序出错。

### 锁的定义
就是一个对象，它包含了一些字段，这些字段中维护了锁的状态。锁有非常直观的API：
- acquire
- release
- 锁的acquire和release之间的代码，通常被称为critical section。
[[自动加锁补充#^2f9f8a]]锁应该与操作而不是数据关联，所以自动加锁在某些场景下会出问题。
<!--ID: 1764664441538-->


### 锁的作用
- locks help avoid lost updates
- locks make multistep op atomic
- locks help maintin invariant
<!--ID: 1764664441541-->


### 锁的挑战
#### 死锁
锁排序
**如果你有多个锁，你需要对锁进行排序，所有的操作都必须以相同的顺序获取锁。**以避免死锁
[[book#^n2sdp346aac]]
<!--ID: 1764664441544-->


#### 锁破坏程序的模块化
**定义一个全局的锁的顺序会有些问题**。
[[10.4-locks-properties-and-deadlock#^ec5112]]
<!--ID: 1764664441547-->


#### 锁与性能的权衡
我们想要获得更好的性能，那么我们需要有更多的锁，但是这又引入了大量的工作。
通常来说，开发的流程是：
*   先以coarse-grained lock（注，也就是大锁）开始。
*   再对程序进行测试，来看一下程序是否能使用多核。
*   如果可以的话，那么工作就结束了，你对于锁的设计足够好了；如果不可以的话，那意味着锁存在竞争，多个进程会尝试获取同一个锁，因此它们将会序列化的执行，性能也上不去，之后你就需要重构程序。
<!--ID: 1764664441550-->


### 自旋锁的实现
最常见的方法是依赖于一个特殊的硬件指令。这个特殊的硬件指令会保证一次test-and-set操作的原子性。
<!--ID: 1764664441554-->


>为什么release函数中不直接使用一个store指令将锁的locked字段写为0？[[10.8-spin-lock-2#^29f9b9]]

>为什么acquire函数最开始会先关闭中断？[[10.8-spin-lock-2#^ac9123]]

>memory ordering。[[10.8-spin-lock-2#^0c79aa]]