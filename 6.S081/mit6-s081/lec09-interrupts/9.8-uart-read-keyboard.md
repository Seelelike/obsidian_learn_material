> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mit-public-courses-cn-translatio.gitbook.io](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec09-interrupts/9.8-uart-read-keyboard)

Copy

1.  [Lec09 Interrupts (Frans)](/mit6-s081/lec09-interrupts)

9.8 UART读取键盘输入
==============

在UART的另一侧，会有类似的事情发生，有时Shell会调用read从键盘中读取字符。 在read系统调用的底层，会调用fileread函数。在这个函数中，如果读取的文件类型是设备，会调用相应设备的read函数。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNpiXXVKJdvWgWqzH_y%252F-MNrubhKUjW6DnLvxjQ6%252Fimage.png%3Falt%3Dmedia%26token%3D04539d08-79e8-463e-ad43-79b36da29eaa&width=768&dpr=4&quality=100&sign=99599584&sv=2)

在我们的例子中，read函数就是console.c文件中的consoleread函数。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNpiXXVKJdvWgWqzH_y%252F-MNrv41RJWmQNiCKb4Ve%252Fimage.png%3Falt%3Dmedia%26token%3De274c0e1-526c-49ab-83f9-f2a15447cd8f&width=768&dpr=4&quality=100&sign=30bd9c61&sv=2)

这里与UART类似，也有一个buffer，包含了128个字符。其他的基本一样，也有producer和consumser。但是在这个场景下Shell变成了consumser，因为Shell是从buffer中读取数据。而键盘是producer，它将数据写入到buffer中。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNpiXXVKJdvWgWqzH_y%252F-MNrvQJe25cNXU0LuIaw%252Fimage.png%3Falt%3Dmedia%26token%3D3a872797-b8ed-4d68-86ff-ff24403d2475&width=768&dpr=4&quality=100&sign=98d7731e&sv=2)

从consoleread函数中可以看出，当读指针和写指针一样时，说明buffer为空，进程会sleep。所以Shell在打印完“$ ”之后，如果键盘没有输入，Shell进程会sleep，直到键盘有一个字符输入。所以在某个时间点，假设用户通过键盘输入了“l”，这会导致“l”被发送到主板上的UART芯片，产生中断之后再被PLIC路由到某个CPU核，之后会触发devintr函数，devintr可以发现这是一个UART中断，然后通过uartgetc函数获取到相应的字符，之后再将字符传递给consoleintr函数。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNrxZk5JKK8WT1bCv_K%252F-MNs0P8PukOn1-st2X5I%252Fimage.png%3Falt%3Dmedia%26token%3Dae576029-e271-4a0f-8c6e-ae85b1272d76&width=768&dpr=4&quality=100&sign=8851cb56&sv=2)

默认情况下，字符会通过consputc，输出到console上给用户查看。之后，字符被存放在buffer中。在遇到换行符的时候，唤醒之前sleep的进程，也就是Shell，再从buffer中将数据读出。

所以这里也是通过buffer将consumer和producer之间解耦，这样它们才能按照自己的速度，独立的并行运行。如果某一个运行的过快了，那么buffer要么是满的要么是空的，consumer和producer其中一个会sleep并等待另一个追上来。

[Previous9.7 Interrupt相关的并发](9.7-interrupt-related-concurrency.md)[Next9.9 Interrupt的演进](9.9-interrupt-envolving.md)

Last updated 4 years ago

Was this helpful?