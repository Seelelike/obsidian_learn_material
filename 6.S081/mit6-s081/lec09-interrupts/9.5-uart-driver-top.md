> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mit-public-courses-cn-translatio.gitbook.io](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec09-interrupts/9.5-uart-driver-top)

9.5 UART驱动的top部分
================

接下来我想看一下如何从Shell程序输出提示符“$ ”到Console。首先我们看init.c中的main函数，这是系统启动后运行的第一个进程。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNa7TJFrEQk2gYzkwCG%252F-MNcplHF86eYTpFW_ztO%252Fimage.png%3Falt%3Dmedia%26token%3De445273b-fd4d-4b8f-ad9a-100f621a2b62&width=768&dpr=4&quality=100&sign=c7cdf438&sv=2)

首先这个进程的main函数创建了一个代表Console的设备。这里通过mknod操作创建了console设备。因为这是第一个打开的文件，所以这里的文件描述符0。之后通过dup创建stdout和stderr。这里实际上通过复制文件描述符0，得到了另外两个文件描述符1，2。最终文件描述符0，1，2都用来代表Console。

Shell程序首先打开文件描述符0，1，2。之后Shell向文件描述符2打印提示符“$ ”。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNa7TJFrEQk2gYzkwCG%252F-MNcqqRtbogpSiiEpc2P%252Fimage.png%3Falt%3Dmedia%26token%3Da1ae7eb6-b01d-4886-93ba-771f0bbe4182&width=768&dpr=4&quality=100&sign=75c75e07&sv=2)

尽管Console背后是UART设备，但是从应用程序来看，它就像是一个普通的文件。Shell程序只是向文件描述符2写了数据，它并不知道文件描述符2对应的是什么。在Unix系统中，设备是由文件表示。我们来看一下这里的fprintf是如何工作的。

在printf.c文件中，代码只是调用了write系统调用，在我们的例子中，fd对应的就是文件描述符2，c是字符“$”。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNa7TJFrEQk2gYzkwCG%252F-MNcryjzrhmCyPc7r_gD%252Fimage.png%3Falt%3Dmedia%26token%3Dbaf1d557-0d54-47c4-8cdf-29f409a1d04d&width=768&dpr=4&quality=100&sign=b664dbe8&sv=2)

所以由Shell输出的每一个字符都会触发一个write系统调用。之前我们已经看过了write系统调用最终会走到sysfile.c文件的sys_write函数。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNa7TJFrEQk2gYzkwCG%252F-MNcsd0dxYGOsPE0DkWF%252Fimage.png%3Falt%3Dmedia%26token%3D690b04c3-fff7-4c46-85a0-44038c36c101&width=768&dpr=4&quality=100&sign=44596366&sv=2)

这个函数中首先对参数做了检查，然后又调用了filewrite函数。filewrite函数位于file.c文件中。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNa7TJFrEQk2gYzkwCG%252F-MNct2PHzPhwjA3hvi6V%252Fimage.png%3Falt%3Dmedia%26token%3D30bb0476-6724-473c-a36f-6ed0de37104f&width=768&dpr=4&quality=100&sign=3d261c72&sv=2)

在filewrite函数中首先会判断文件描述符的类型。mknod生成的文件描述符属于设备（FD_DEVICE），而对于设备类型的文件描述符，我们会为这个特定的设备执行设备相应的write函数。因为我们现在的设备是Console，所以我们知道这里会调用console.c中的consolewrite函数。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNa7TJFrEQk2gYzkwCG%252F-MNctcQci75CDpfVpdRq%252Fimage.png%3Falt%3Dmedia%26token%3D08880b86-4d8f-4b67-aa3c-cc5ce6cb17b0&width=768&dpr=4&quality=100&sign=2275b9c8&sv=2)

这里先通过either_copyin将字符拷入，之后调用uartputc函数。uartputc函数将字符写入给UART设备，所以你可以认为consolewrite是一个UART驱动的top部分。uart.c文件中的uartputc函数会实际的打印字符。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNa7TJFrEQk2gYzkwCG%252F-MNcu9oxFUI2qpie5z4T%252Fimage.png%3Falt%3Dmedia%26token%3Db0201ce3-225c-4696-a5e4-348e1b081bcc&width=768&dpr=4&quality=100&sign=ede7951e&sv=2)

uartputc函数会稍微有趣一些。在UART的内部会有一个buffer用来发送数据，buffer的大小是32个字符。同时还有一个为consumer提供的读指针和为producer提供的写指针，来构建一个环形的buffer（注，或者可以认为是环形队列）。 ^a42cb9

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNa7TJFrEQk2gYzkwCG%252F-MNcudamCocCj7PtfYpv%252Fimage.png%3Falt%3Dmedia%26token%3Df9ff4004-3b5d-4c5a-bbf2-676d10dc2033&width=768&dpr=4&quality=100&sign=77dde729&sv=2)

在我们的例子中，Shell是producer，所以需要调用uartputc函数。在函数中第一件事情是判断环形buffer是否已经满了。如果读写指针相同，那么buffer是空的，如果写指针加1等于读指针，那么buffer满了。当buffer是满的时候，向其写入数据是没有意义的，所以这里会sleep一段时间，将CPU出让给其他进程。当然，对于我们来说，buffer必然不是满的，因为提示符“$”是我们送出的第一个字符。所以代码会走到else，字符会被送到buffer中，更新写指针，之后再调用uartstart函数。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MNcv-xytcPNjgcA09N-%252F-MNfDMD08BsxVVcKpVl3%252Fimage.png%3Falt%3Dmedia%26token%3D58e70d9b-7dd2-46bb-8243-bb188dcb8307&width=768&dpr=4&quality=100&sign=abdbf7a1&sv=2)

uartstart就是通知设备执行操作。首先是检查当前设备是否空闲，如果空闲的话，我们会从buffer中读出数据，然后将数据写入到THR（Transmission Holding Register）发送寄存器。这里相当于告诉设备，我这里有一个字节需要你来发送。一旦数据送到了设备，系统调用会返回，用户应用程序Shell就可以继续执行。这里从内核返回到用户空间的机制与lec06的trap机制是一样的。 ^aa06c7

与此同时，UART设备会将数据送出。在某个时间点，我们会收到中断，因为我们之前设置了要处理UART设备中断。接下来我们看一下，当发生中断时，实际会发生什么。

[Previous9.4 在XV6中设置中断](9.4-xv6-set-interrupt.md)[Next9.6 UART驱动的bottom部分](9.6-uart-driver-bottom.md)
