### device drivers

#### 中断相关寄存器
[[9.4-xv6-set-interrupt#^b078f7]]
- SIE（Supervisor Interrupt Enable）寄存器。针对外部设备的中断；针对软件中断；针对定时器中断。 ^b3898c
- SSTATUS（Supervisor Status）寄存器。来打开或者关闭中断。每一个CPU核都有独立的SIE和SSTATUS寄存器。 ^930c2b
- SIP（Supervisor Interrupt Pending）寄存器。当前是什么类型的中断。
- SCAUSE寄存器，表明当前状态的原因是中断。 ^86d120
- STVEC寄存器，保存CPU运行的用户程序的程序计数器。
<!--ID: 1764664441586-->


#### 中断与系统调用的区别

1. asynchronous。Interrupt handler与当前运行的进程在CPU上没有任何关联。[[9.2-interrupt-handware#^8c6e3c]]
2.  concurrency。CPU和生成中断的设备是并行的
3. program device。设备需要被编程。
<!--ID: 1764664441589-->


#### 中断硬件

所有的设备都连接到处理器上，处理器上是通过Platform Level Interrupt Control，简称PLIC来处理设备中断。PLIC会管理来自于外设的中断。
[[9.2-interrupt-handware#^d589ed]]
<!--ID: 1764664441592-->

#### 驱动

管理设备的代码称为驱动，所有的驱动都在内核中。
<!--ID: 1764664441597-->


驱动分为两个部分，top、bottom。
[[9.3-device-driver#^6f9b20]]
- bottom部分通常是Interrupt handler。Interrupt handler并不运行在任何特定进程的context中
- top部分，是用户进程，或者内核的其他部分调用的接口。
- 通常情况下，驱动中会有一些队列可以将并行运行的设备和CPU解耦开来。
#### 编程设备
[[9.3-device-driver#^a0daa5]]
编程是通过memory mapped I/O完成的。在SiFive的手册中，设备地址出现在物理地址的特定区间内，这个区间由主板制造商决定。
<!--ID: 1764664441602-->


#### "Console上如何显示$"
[[9.4-xv6-set-interrupt#^9f80d0]]
`start()`将所有的中断都设置在Supervisor mode，然后设置[[#^b3898c|SIE]]寄存器来接收External，软件和定时器中断，之后初始化定时器。
`main()`调用函数`consoleinit()``plicinit()``plicinithart()`进行`scheduler()`初始化。
`consoleinit()`初始化uart`uartinit()`、注册设备读写函数。
`uartinit()`配置uart芯片，包括波特率、字长、停止校验位等。
`plicinit()`使能UART、IO磁盘中断。
`plicinithart()`每个cpu核调用该函数表面对哪些外设中断感兴趣。
`scheduler()`运行进程并执行`intr_on`使能cpu接收中断。
`intr_on`设置[[#^930c2b|SSTAUS]]寄存器
<!--ID: 1764664441605-->


第一个进程`main`函数创建Console设备，并通过[[dup]]得到文件描述符0、1、2，都代表Console。
Shell程序打开文件描述符0、1、2并向2打印"\$"`fprintf(2,"$")`,调用write系统调用。
`sys_write`对参数检查后调用`filewrite`。`filewrite`会判断文件描述符类型，由于属于设备类型，对执行设备相应的write函数，`consolewrite`。consolewrite相当于uart的**top部分**
`consolewrite`调用`uartputc`
[[9.5-uart-driver-top#^a42cb9|uartputc]]函数将字符放入buf、更新写指针并调用`uartstart`。
[[9.5-uart-driver-top#^aa06c7|uartstart]]从buffer中读出数据，然后将数据写入到THR寄存器。相当于告诉设备，我这里有一个字节需要你来发送。一旦数据送到了设备，系统调用会返回，用户应用程序Shell就可以继续执行。这里从内核返回到用户空间的机制与lec06的trap机制是一样的。

#### 外设中断处理流程
- 清除SIE寄存器bit
- 设置SEPC寄存器
- 保存当前mode
- 设置mode为S mode
- 设置程序计数器为STVEC值
- usertrap函数处理外部中断：
`devintr()`通过[[#^86d120|SCAUSE]]判断是否为外设中断，然后调用`plic_claim()`获取中断。`plic_claim()`会返回外设的中断号。
如果是UART中断，则会调用[[9.6-uart-driver-bottom#^2cc1b0|uartintr()]]。
<!--ID: 1764664441608-->


#### 中断相关并发
- 设备与CPU是并行的
- 中断会打断当前程序
- 驱动的top与bottom部分是并行运行的。
[[9.7-interrupt-related-concurrency#^03b427]]

#### "Console上如何显示ls"
`consoleread()`读取buf
uart接收到字符后，触发uartintr()、然后调用`consoleintr()`,字符会通过consputc，输出到console上给用户查看。之后，字符被存放在buffer中。在遇到换行符的时候，唤醒之前sleep的进程，也就是Shell，再从buffer中将数据读出。
<!--ID: 1764664441611-->


[[9.9-interrupt-envolving|polling轮询]]