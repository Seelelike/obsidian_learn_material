**文件系统**：组织与存储数据，支持用户与应用间数据共享，并使数据具有持久性
挑战
- 磁盘上要有数据结构、记录各种信息
- 要能够应对崩溃
- 允许多个进程同时操作
- 磁盘比内存慢，需要缓存用于加速

### 文件系统的结构（从下向上）
![[Pasted image 20251119152002.png]]
1. Disk：负责在virtio硬盘上读写块。
2. buffer cache：在内存中存放部分磁盘块的副本，减少磁盘的访问次数
3. logging：用于避免崩溃，将上层对多个块的修改打包成一个事务。
4. inode：提供单个文件的抽象
5. directory：目录层
6. pathname：路径名层
7. file descriptor：将Unix资源同一抽象为文件形式。
<!--ID: 1764664441386-->


### 磁盘数据布局
![[Pasted image 20251119152601.png]]
一串编号的512字节块。（操作系统里的块大小一般为其整数倍）
1. 块0：引导扇区，用于启动
2. 块1：文件系统的元信息
	- 文件系统共多少块
	- 多少数据块
	- 多少inode
	- 多少块日志
3. 块2及之后：日志区
4. inode区：存放所有inode信息
5. bitmap：记录哪些块被使用，哪些块空闲
6. data：数据块
> superblock 是由一个叫 mkfs 的程序写进去的，这个程序负责建立最初的文件系统。
<!--ID: 1764664441388-->



### Buffer cache
用于：
- 同步访问磁盘块（一个磁盘块只有一块buf、同时只有一个线程访问buf）
- 加速访问
```
struct buf {
  int valid;   // has data been read from disk?
  int disk;    // does disk "own" buf?
  uint dev;
  uint blockno;
  struct sleeplock lock;
  uint refcnt;
  struct buf *prev; // LRU cache list
  struct buf *next;
  uchar data[BSIZE];
};
```
<!--ID: 1764664441391-->


`bget\bread\bwrite\brelse`

### 日志
为什么崩溃恢复麻烦？
>如：“把文件长度设为 0，并且把它占用的内容块都释放掉”。需要修改磁盘的inode与bitmap区，如果在之间发生崩溃，可能出现，inode不变，bitmap已被标记为空闲，导致有多个文件使用同一磁盘区。或inode清除，bitmap未被标记空闲，导致空间浪费。
<!--ID: 1764664441394-->


**系统调用不直接改真正的磁盘结构，而是先把“要做哪些改动”写到日志里，再一次性提交。**

操作流程：
1. 需要修改许多地方
2. 先在日志区记录
3. 记完后，在日志中写一条commit记录
4. 把真正的修改复制到文件系统结构中。
5. 操作完成后将日志清空。

崩溃恢复流程
1. 系统重启后先检查日志。
2. 若无commit记录，忽略该日志，因为操作确实没有发生。
3. 若有记录，则重复日志记录的操作。

日志让操作对崩溃来说是**原子**的
>从“崩溃之后、重启恢复完成”的角度看，每一次文件系统操作要么： 完全没发生（所有写都没生效） 要么全部发生（所有写都生效）

日志结构
日志在磁盘的固定位置，且该位置记录在superblock中。
- 一个header block
	- 数组：记录进日志的块的扇区号
	- count：共记录多少块。
- logged blocks

group commit
- 日志层可以把多个系统调用的写操作放到同一个事务里。 
- 只有在当前没有文件系统调用正在进行时，才真正执行一次 commit。 
- 这样就不会把一个系统调用拆开到两个事务里去。
可减少磁盘操作次数，让磁盘更顺利地写

日志空间是固定大小的
- 单个系统调用不能写太多块
- 日志系统不会让一定装不下的系统调用开始。

日志代码实现
```
begin_op();
... 
bp = bread(...); 
bp->data[...] = ...; 
log_write(bp); 
... 
end_op();
```
在每次文件系统调用时
- `begin_op`：等待日志完成commit，等待日志释放足够的空间，outstanding+1，表示占位置。
- log_write：写进日志代替直接bwrite，保存扇区号在日志系统的**内存**中的logheader数组中，将buf钉在缓存中。（b->refcnt++）
- end_op：outstanding-1，表示系统调用结束。如果outstanding为0，表示当前无如何文件系统调用正在进行，则，commit
- commit：write_log，将修改过的块，从buf cache复制到磁盘对应位置，将日志的header写进磁盘，此时真正**提交**，install_trans,从logged blocks中读出并写进对应原本的磁盘位置，最后清零header的count。
注意操作的是内存还是磁盘。


### 块分配器
- 用一个磁盘上的 bitmap（一位管一块）记录块是否空闲：
	- 0 → 空闲 
	- 1 → 使用中 
- balloc： 
	- 扫描 bitmap，找到 bit=0 的块，把它设成 1，返回这个块号。 
	- 外层循环按 bitmap 块读，内层循环按 bit 读，提高效率。 
	- buffer cache 保证同一 bitmap 块同一时刻只被一个进程改，避免竞争。 
- bfree： 
	- 找到 bitmap 中对应的那一位，设成 0。 
- 它们都必须放在事务里执行，以便在崩溃时由日志保护。
<!--ID: 1764664441397-->



### inode
- 磁盘中的inode
```
struct dinode {
  short type;           // File type
  short major;          // Major device number (T_DEVICE only)
  short minor;          // Minor device number (T_DEVICE only)
  short nlink;          // Number of links to inode in file system
  uint size;            // Size of file (bytes)
  uint addrs[NDIRECT+1];   // Data block addresses
};
```
- 内存中的inode
```
struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Reference count
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?
  short type;         // copy of disk inode
  short major;
  short minor;
  short nlink;
  uint size;
  uint addrs[NDIRECT+1];
};
```
<!--ID: 1764664441400-->


磁盘上的inode大小相等，存放在inode block中，因此只需要知道i-number就能知道其在磁盘上的位置。
- type：为0表示空
- nlink：链接计数
- size：文件内容大小
- ddrs：文件存在在磁盘的块号。

内存上的inode
- ref：记录被多少指针引用。（打开的文件、当前工作目录、内核临时操作。）

四种保护机制：
- itable.lock：保持同一inode只出现在table一次，保持ref计数正确。
- inode.lock：保护inode字段及对应内容数据块。
- ref>0
- nlink

`iget`获取指针。
`ilock`独占地操作inode内容。
`iput`释放指针，可能会删除文件。**所有这类系统调用都必须被事务（logging）包起来。**

孤儿inode问题：文件的nlink变为0，但仍被引用，此时系统崩溃，磁盘中inode的type不为0，但没任何目录指向它。
解决方法：
- 重启后全屏扫描。
- 维护一个待清理inode列表。

inode content
![[Pasted image 20251119174817.png]]
一个文件的内容块位置是这样存的：
- addrs\[0..NDIRECT-1\]：直接块号（direct blocks） 
- addrs\[NDIRECT\]：一个“间接块”的块号，间接块里再存更多数据块号

bmap(ip, bn)：
- 返回 “第 bn 个数据块” 的磁盘块号；
- 如果没有就顺便分配；
- 帮上层隐藏 direct / indirect 的复杂度。
itrunc(ip)：
- 释放所有 direct 块；
*   释放所有 indirect 块内的块；  
*   释放间接块自身；
*   把 `ip->size` 设为 0。

readi / writei：
*   都是按 “一个一个数据块” 循环：
	*   调 `bmap` 找块号；
	*   `bread` 得到 `bp`；
	*   在块里算偏移和长度；
	*   `readi` 是从 `bp->data` 拷到用户；
	*   `writei` 是从用户拷到 `bp->data`，再通过日志写回；
*   `writei` 还能扩展文件，并更新 `ip->size`。

如果 `ip->type == T_DEV`，
*   表示这是设备文件，不走普通文件系统那一套，
*   会走设备的专门读写逻辑。

stati：
*   把 inode 的元数据搬到 `struct stat` 里，让 `stat()` 系统调用返回给用户。


### 目录
本质上是一种特殊的文件
type = T_IR。
内容是一串目录项 dirent
<!--ID: 1764664441404-->


```
struct file {
  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;
  int ref; // reference count
  char readable;
  char writable;
  struct pipe *pipe; // FD_PIPE
  struct inode *ip;  // FD_INODE and FD_DEVICE
  uint off;          // FD_INODE
  short major;       // FD_DEVICE
};
```