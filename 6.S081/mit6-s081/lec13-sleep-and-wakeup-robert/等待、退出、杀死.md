> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [chat.zchat.tech](https://chat.zchat.tech/c/6912b03b-a5bc-832a-8a72-7c478c14034b)

> ChatGPT helps you get answers, find inspiration and be more productive. It is free to use and easy to......

下面把 **7.8：wait / exit / kill** 的核心机制与 “为什么这样就不会丢事件 / 不会死锁 / 不会乱改状态” 讲透。你可以把这三者理解为：

*   `exit`：**孩子结束**时如何把 “死亡事实” 可靠地留给家长去领；
    
*   `wait`：**家长领尸**，安全地取走退出码并回收资源；
    
*   `kill`：**外部请求**让某进程尽快自杀，但要用安全、温和的方式实现。
    

* * *

1) 进程终结协议：ZOMBIE 中转站
--------------------

**目标：** 无论父进程是在等待、还是忙别的事，**都要保证**它最终能看见孩子已死并且能回收资源 / 拿到退出码。

**做法：** 孩子在 `exit()` 里把自己置为 **ZOMBIE**：

*   ZOMBIE = “进程不再运行，但**它的 `struct proc` 和退出码先保留**，留待父亲 `wait()` 领取”。
    
*   父亲的 `wait()` 看见某个孩子是 ZOMBIE → 拿退出码 → 把孩子的 `state` 置为 `UNUSED` → 归还 PID、释放资源。
    

**兜底：** 如果**父亲先死了**，`exit()` 会把所有孩子 **reparent** 给 `init` 进程（`init` 永远循环 `wait()`），保证**每个孩子总有家长**来收尸。

* * *

2) 竞态与死锁如何避免：锁与顺序
-----------------

这套协议里有三种并发：

*   父 `wait` 与子 `exit` **同时**发生；
    
*   多个孩子之间并发 `exit`；
    
*   父 / 子都在不同 CPU 上。
    

### 关键锁与顺序

*   **`wait_lock`**：作为 “条件锁 / 队列锁”，串联“孩子退出 → 唤醒父亲” 的事件；
    
*   **`p->lock`**：保护**单个进程**的 `state`、`context` 等不变量。
    
<!--ID: 1764664441445-->


**规范顺序（避免死锁）：**

> 始终先拿 `wait_lock`，再拿某个进程的 `p->lock`（在 `wait` 和 `exit` 中一致）。

### `wait()` 的流程（简化）

1.  `acquire(wait_lock)`（把它当作**条件锁**用）。
    
2.  扫描进程表：
    
    *   若有**自己孩子**是 **ZOMBIE** → 回收它、复制退出码、`UNUSED`、返回 PID；
        
    *   若有孩子但都还没死 → `sleep(parent, wait_lock)`（或 sleep 在一个约定通道上），然后**醒来再扫**。
        
    *   若无孩子 → 返回 `-1`。
        
3.  扫描孩子条目时，访问每个孩子会临时 `acquire(np->lock)`（注意锁顺序：先 `wait_lock` 后 `np->lock`）。
    
<!--ID: 1764664441451-->


### `exit()` 的流程（简化）

1.  记录退出码；
    
2.  释放自身部分资源；
    
3.  **reparent** 孩子给 `init`；
    
4.  **持有** `wait_lock` **并** `p->lock`：
    
    *   `wakeup(parent)`：**唤醒**可能在 `wait()` 的父亲；
        
    *   `p->state = ZOMBIE`；
        
    *   **让出 CPU**（永不再返回用户态）。
        
    *   这两个锁的获取顺序与 `wait()` 一致，避免死锁。
        
<!--ID: 1764664441454-->


> **为什么 “可以先 wakeup 再设 ZOMBIE” 也安全？**  
> 因为此时 `exit` **还持有 `p->lock`**，即使父亲被唤醒并开始跑 `wait()`，它在扫描到该孩子之前也会尝试 `acquire(p->lock)`，而这把锁要等到 `scheduler` 切走孩子、**真正释放 `p->lock`** 后父亲才能拿到——那时 `exit` 已经把 `state` 设成了 ZOMBIE。  
> 所以 **父亲不可能 “看到一半”** 的状态，不会误判。

* * *

3) 为什么 `wait_lock` 是 “条件锁”
--------------------------

*   它把 “**孩子退出**（发出 wakeup）” 与 “**父亲 wait**（sleep 等待）” 这两端**串起来**，防止**丢失唤醒**：
    
    *   持 `wait_lock` 时，父亲要么还没 sleep，孩子还不能错过它；要么父亲已经 sleep，孩子持相同锁发的 `wakeup` 也不会丢。
        
*   `wait()` 经常同时持有 `wait_lock` + `np->lock`（某个孩子锁），所以规定了**锁顺序**来避免死锁：**先 `wait_lock` 后 `np->lock`**。`exit()` 也必须按这个顺序拿两把锁。
    

* * *

4) `kill()`：温和但可靠的 “远程终止”
-------------------------

**目标：** 让一个进程终止，但**不要在别的 CPU 的中间指令里直接 “拔电源”**（那会破坏内核状态）。

**做法：**

*   `kill(pid)` **仅仅设置** 目标的 `p->killed = 1`；
    
*   如果目标正在 `sleep`，再 `wakeup(目标)` 让它从 `sleep` 返回；
    
*   之后 **在合适时机**（进入内核或中断 / 系统调用返回路径），  
    由 `usertrap` 或系统调用路径看到 `p->killed`，**调用 `exit()`**，从而干净退出。
    

**为什么安全：**

*   不在别的 CPU“中途” 撤掉进程；
    
*   让它自己走正常的 “退出协议”（`exit` → `ZOMBIE` → 父 `wait` 回收）。
    

**注意：**

*   被 `wakeup` 从 `sleep` 唤醒时，等待的条件可能还不成立（**伪唤醒**）；
    
*   因为所有 `sleep` 都在 `while(条件不成立) sleep()` 循环里，**醒来后会再检查条件**；
    
*   有些 `sleep` 循环还会检查 `p->killed`，若置位就**提前放弃**当前操作并尽快返回到 `trap`，以便 `exit`。
    
*   **也有**不检查 `p->killed` 的场景（例如 virtio 磁盘驱动一次系统调用里的一系列写操作必须原子完成，以免文件系统坏掉）。这类系统调用会**完成之后**再由 `usertrap` 看到 `p->killed` 并 `exit`。
    

* * *

5) 把关键时序串成两条 “故事线”
------------------

### A. 孩子先死，父亲随后 wait

1.  子：`exit()` → 设退出码、reparent、**(hold wait_lock & p->lock) → wakeup(parent) → state=ZOMBIE → swtch**。
    
2.  父：`wait()` → **持 `wait_lock`** 扫描 → 看到孩子 **ZOMBIE** → 回收、取退出码、`UNUSED`、返回 PID。
    
<!--ID: 1764664441457-->


### B. 父亲早就 `wait` 睡着，孩子这时死

1.  父：`wait()` 发现没 ZOMBIE，**在持 `wait_lock` 下 `sleep`**。
    
2.  子：`exit()` **持 `wait_lock`** `wakeup(parent)` → 设 `ZOMBIE` → 让出 CPU。
    
3.  父：被唤醒（拿到 `wait_lock`），扫描 → 看到孩子 `ZOMBIE` → 回收。
    
<!--ID: 1764664441460-->


**两种情形都不丢事件**，因为 `wait_lock` 使得 “睡眠 / 唤醒” 之间有**原子衔接**。

* * *

6) 一页速记（要点表）
------------

*   **ZOMBIE**：孩子结束后的中转状态；父亲 `wait` 看到后回收。
    
*   **wait_lock**：父子之间的 “条件锁”，串起 **sleep/wakeup**，防止丢唤醒。
    
*   **锁顺序**：统一为 **`wait_lock` → `p->lock`**，`wait/exit` 都遵守，避免死锁。
    
*   **exit**：持两把锁，`wakeup(parent)` **可以先发**，但 `p->lock` 还没释放，父亲不能过早观察；随后置 `ZOMBIE` 并让出 CPU。
    
*   **wait**：持 `wait_lock` 扫描，遇 ZOMBIE 回收；否则在 `wait_lock` 下 `sleep`。
    
*   **kill**：只置 `p->killed`，若在睡则 `wakeup`；真正退出由 **trap 路径**触发 `exit`。
    
*   **伪唤醒安全**：所有 `sleep` 在 `while(条件不满足)` 里，醒后重查；部分路径再检查 `p->killed` 以尽快终止。
    
*   **原子多步系统调用**（如磁盘写）：中途**不**检查 `p->killed`，避免破坏一致性；结束后再退出。
    

* * *

如果你想，我可以把 `wait` 与 `exit` 的**真实 xv6 源码关键片段**挑出来，边标注行号边对照上述要点，再画一张 “父 - 子状态 / 锁 / 唤醒” 时序图，帮助你把这段流程与代码逐行对齐。
