进程切换大致流程
1.  一个进程要进入休眠状态，先获取自己的锁；
2.  将自己的状态从RUNNING设置为RUNNABLE；
3.  之后进程调用switch函数；
4.  switch函数将当前的线程切换到调度器线程；
5.  调度器线程之前也调用了switch函数，现在恢复执行**会从自己的switch函数返回**；
6.  返回之后，调度器线程会释放刚刚出让了CPU的进程的锁

为什么要获取自己的进程锁？
>在2-3的过程中，其他cpu可能发现该进程为RUNNABLE并运行它，会造成同一进程在两个cpu上运行的情况。

为什么不允许进程在执行switch函数的过程中，持有任何其他的锁？
>进程P1，通过调用switch/yield/sched函数出让CPU，这会导致进程P1持有了锁，但是进程P1又不在运行。此时P2尝试acquire该锁，则处于循环等待状态，而acquire函数在等待锁之前会关闭中断(参考[[10.8-spin-lock-2#^66a93f|10.8]])，否则的话可能会引起死锁，所以我们不能在等待锁的时候处理中断。

为什么sleep需要一个锁使用作为参数传入？
>会发生唤醒丢失，在sleep之前将锁释放，在释放锁与睡眠之间，唤醒程序可能一直在acquire该锁，那么当该进程进入睡眠之前，wake信号就已经发出，就丢失了一次睡眠。

为什么需要通过一个循环while(tx_done == 0)来调用sleep函数？
>实际中不太可能将sleep和wakeup精确匹配。并不是说sleep函数返回了，你等待的事件就一定会发生。[[13.3-lost-wakeup#^2ce370]]

睡眠唤醒规则
*   调用sleep时需要持有condition lock，这样sleep函数才能知道相应的锁。
*   sleep函数只有在获取到进程的锁p->lock之后，才能释放condition lock。
*   wakeup需要同时持有两个锁才能查看进程。

清除进程的两个问题
- 我们不能直接单方面的摧毁另一个线程[[13.6-exit-systemcall#^42ef74]]
- 正在运行的进程自己决定退出。它不能释放运行代码所需要的一些资源。

exit执行功能
- 关闭所有打开的文件
- 释放当前工作目录
- 处理子进程，改其父为init进程
- 唤醒父进程
- 标记自己为ZOMBIE
- 让出cpu
为什么我们在唤醒父进程之后才将进程的状态设置为ZOMBIE？
>正在退出的进程会先获取自己进程的锁，同时，因为父进程的wait系统调用中也需要获取子进程的锁，所以父进程并不能查看正在执行exit函数的进程的状态。[[13.7-wait-systemcall#^7f7f8f]]

在exit系统调用中，为什么需要在重新设置父进程之前，先获取当前进程的父进程？
>这里其实就是在防止一个进程和它的父进程同时退出。


wait执行功能
- 扫描进程表单，找到父进程是自己且状态是ZOMBIE的进程。
- freeproc，释放子进程在exit中不方便释放的资源

kill执行功能
- 先扫描进程表单，找到目标进程。将进程的proc结构体中killed标志位设置为1。如果进程正在SLEEPING状态，将其设置为RUNNABLE。
- 而目标进程运行到内核代码中能安全停止运行的位置时，会检查自己的killed标志位，如果设置为1，目标进程会自愿的执行exit系统调用。