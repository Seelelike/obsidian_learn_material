用户应用程序也应该从灵活的虚拟内存中获得收益，也就是说用户应用程序也可以使用虚拟内存。用户应用程序本身就是运行在虚拟内存之上，我们这里说的虚拟内存是指：User Mode或者应用程序想要使用与内核相同的机制，来产生Page Fault并响应Page Fault

- 内核中发生的page fault能够传递到用户空间，供用户的handle处理
- Prot1、ProtN，降低一个内存Page的accessability
- Unprot，增加一个内存Page的accessability
- 查看内存Page是否Dirty
- map2，将特定内存地址映射两次，且有不同的accessability

### 系统调用
- `mmap(null,len,R/W,MAP_PRIVATE,fd,offset)`映射内存、文件
- `mprotect(addr,len,R)`当你将某个对象映射到虚拟内存地址空间，你可以修改对应虚拟内存的权限。
- `munmap`，解除一个地址的映射关系。
- `sigaction`是应用程序可以设定好特定signal发生就调用特定函数。
<!--ID: 1764664441366-->


### 虚拟内存系统支持用户应用程序的两个实现
- VMAs：VMA会记录一些有关连续虚拟内存地址段的信息。在一个地址空间中，可能包含了多个section，每一个section都由一个连续的地址段构成，对于每个section，都有一个VMA对象。连续地址段中的所有Page都有相同的权限，并且都对应同一个对象VMA
- User level trap
	- trap handler会查看VMA举个例子，如果是segfault，并且应用程序设置了一个handler来处理它
	- segfault事件会被传播到用户空间
	- 通过一个到用户空间的upcall在用户空间运行handler
	- 在handler中或许会调用mprotect来修改PTE的权限
	-  之后handler返回到内核代码
	- 内核再恢复之前被中断的进程。
<!--ID: 1764664441370-->


为什么用户可以针对page fault运行handler代码而不引入安全漏洞？
>upcall调用handler，在用户空间，使用相同的page table，handler无法访问其他应用程序的page table

### 虚拟内存优化GC
GC是指编程语言替程序员完成内存释放，这样程序员就不用像在C语言中一样调用free来释放内存。对于拥有GC的编程语言，程序员只需要调用类似malloc的函数来申请内存，但是又不需要担心释放内存的过程。
<!--ID: 1764664441373-->


Copying GC

通过虚拟内存，将to区域划分成unscanned与scanned区域，开始时先将一页page放入unscanned区域，当程序需要使用时，由于unscanned中节点的指针还在from区域，因此出发page fault扫描该页节点的指针并将指向的节点移入to区域的unscanned区域，并将原page移入scanned区域（unprot）恢复权限。
这种方案的好处是，它仍然是递增的GC，因为每次只需要做一小部分GC的工作。除此之外，它还有额外的优势：现在不需要对指针做额外的检查了。或者说现在**通过虚拟内存相关的硬件来完成指针检查**。

为什么程序访问unscanned的page会触发page fault而GC不会？
使用map2，将同一个物理地址映射两次，第一次是为应用程序进行映射，第二次专门为GC映射。在GC的视角中，仍然有from和to空间。在to空间的unscanned区域中，Page具有读写权限。