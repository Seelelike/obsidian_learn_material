monolithic：指操作系统内核是一个完成了各种事情的大的程序。
好处：
- 可移植性，高度抽象的接口通常是可移植的，可以在不修改应用程序的前提下，将其运行在各种各样的硬件之上。
- 隐藏复杂性，Linux/Unix提供地址空间的抽象而不是直接访问MMU硬件的权限。只需要对文件描述符调用read/write就可以。
- 共享资源管理，例如我们将内存管理委托给了内核，内核会跟踪哪些内存是空闲的。这样应用程序就不用考虑这些问题。
- 所有内核子系统可以访问彼此的数据结构。
坏处：
- 大且复杂。不可避免会有bug
- 拥有所有功能，但在有些情况下，并不需要，且不能对此进行优化。
- 应用程序需要遵守内核的设计，无法额外做更多决定。
- 可拓展性，无法更改内核，只能使用内核提供的能力。

微内核的核心：IPC及线程和任务的tiny kernel。
微内核只提供了进程抽象和通过IPC进程间通信的方式，任何想要做的事情，例如文件系统，你都会通过一个用户空间进程来实现，完全不会在内核中实现。
>在内核中唯一需要做的是支持进程/任务/线程，以及支持IPC来作为消息的传递途径，除此之外，内核不用做任何事情。内核中没有任何文件系统，没有任何设备驱动，没有网络协议栈，所有这些东西以普通用户进程在运行。所以这提供给你一种非常小的内核，以及相对少的代码去优化，你可以优化IPC

可以得到的特性（并不必须支持）：
- 更小的内核或许会更加安全
- 可验证是安全的
- 更容易被优化
- 可能会运行的更快，不用为不使用的功能付出代价
- 为应用程序提高更多灵活性
- 代码更加模块化，将内核拆分，并在用户空间的不同部分运行
- 更容易被定制化，用户空间代码通常会比内核更容易被修改，调整和替换
- 更加健壮，将内核运行成用户空间的服务，其中一个出现故障操作系统的剩余部分还是完好的，可以只重启那一个服务。
- 可模拟或运行多个操作系统

挑战：
- 系统调用的最小集并不确定
- 需要开发用户空间服务实现操作系统的其他部分
- IPC是否可以足够快，使微内核具有足够竞争力
- 服务被分开，相较集合时或许会有性能损失。

L4微内核：
- 只有7个系统调用
- 只有13000行代码
- 只包含几个非常基础的抽象。Task，线程，地址空间，IPC。

系统调用：
- Threadcreate，提供一个地址空间ID并要求创建一个新的线程。如果地址空间或者Task不存在，系统调用会创建一个新的Task。所以这个系统调用即可以创建线程，又可以创建Task。
- Send/Recv IPC系统调用。
- Mapping，可以映射内存Page到当前Task或者其他Task的地址空间中。
- Privileged Task，将硬件控制寄存器映射到自己的地址空间中。不知道例如磁盘或者网卡的设备信息，但是实现了设备驱动的用户空间软件可以直接访问设备硬件。
- 可以设置L4将任何一个设备的中断转换成IPC消息。
- 一个Task可以设置L4内核通知自己有关另一个Task的Page Fault。

异步传输：
- 4个系统调用，两个send，两个recv
- 对应8次用户空间内核空间之间的切换，而每一次切换明显都会很慢
- 在recv的时候，需要通过sleep来等待数据出现
- 并且需要至少一次线程调度和context switching来从P1切换到P2
每一次用户空间和内核空间之间的切换和context switching都很费时，因为每次切换，都需要切换Page Table，进而清空TLB，也就是虚拟内存的查找缓存，这些操作很费时。所以这是一种非常慢的实现方式，它包含了大量的用户空间和内核空间之间的切换、消息的拷贝、缓存的分配等等。

同步传输：
- 当P1和P2都到达了内核中，也就是P1因为调用send进入内核，P2因为调用recv进入内核，这时才会发生一些事情。这种方式快的一个原因是，如果P2已经在recv中，P1在内核中执行send可以直接跳回到P2的用户空间，从P2的角度来看，就像是从recv中返回一样，这样就不需要context switching或者线程调度。
- 当send和recv都在内核中时，内核可以直接将消息从用户空间P1拷贝到用户空间P2，而不用先拷贝到内核中，再从内核中拷出来。
- 消息超级小，比如说只有几十个字节，它可以在寄存器中传递，而不需要拷贝，可以称之为Zero Copy。
- 对于非常长的消息，L4可以在一个IPC消息中携带一个Page映射，所以对于巨大的消息，比如说从一个文件读取数据，你可以发送一个物理内存Page，这个Page会被再次映射到目标Task地址空间，这里也没有拷贝。这里提供的是共享Page的权限。
- 对于RPC这种特别的场景，有一个call系统调用，它基本上结合了send和recv，区别是这里不会像两个独立的系统调用一样，先返回到用户空间，再次进入到内核空间。在消息的接收端，会有一个sendrecv系统调用将回复发出，之后等待来自任何人的request消息。这里基本是发送一个回复再加上等待接收下一个request，这样可以减少一半的内核态和用户态切换。

微内核的很多思想都有持久的影响。
- 人们实现了更加灵活和有趣的方法来在微内核上使用虚拟内存。这些复杂的多的接口导致了mmap这样的系统调用合并到了例如Linux的主流操作系统中。
- 论文中将一个操作系统作为一个用户程序运行另一个操作系统之上，今天以另一种方式非常流行的存在：在Virtual Machine Monitor上运行虚拟机。这种方式在各种场景，例如云主机上，都有使用。
- 为了让内核能够具有一个用户空间服务一样的可扩展性，在Linux中演进成了可加载的内核模块，这使得你可以在线修改Linux的工作方式。
- 当然，这里基于IPC的Client-Server支持，也在macOS有所体现，macOS中也有好用的IPC。
