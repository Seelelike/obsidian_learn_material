> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mit-public-courses-cn-translatio.gitbook.io](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec20-kernels-and-hll-frans/20.7-evaluation-hll-benefits)

Copy

1.  [Lec20 Kernels and HLL (Frans)](/mit6-s081/lec20-kernels-and-hll-frans)

20.7 Evaluation: HLL benefits
=============================

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MY7pNlS8Yc_EQudZc-J%252F-MY7pPtg7Aeko23tWSEi%252Fimage.png%3Falt%3Dmedia%26token%3D8414fa78-c36c-467b-9596-cf085b9f1bfa&width=768&dpr=4&quality=100&sign=5441df9c&sv=2)

Biscuit的实现与其他内核，例如XV6，非常相似，除了Biscuit比XV6性能要高的多。Biscuit采用了很多Linux内核的优化和聪明的设计：

*   我们对于内核文本采用了大页，以避免TLB的代价。
    
*   我们有针对每个CPU的网卡队列，这样可以避免CPU核之间同步。
    
*   我们有RCU实现了不需要读锁的Directory Cache。
    
*   ……
    

通常为了高性能而做的优化，编程语言并不会成为阻碍。Golang并没有成为阻碍这些优化实现的因素。这些优化之前是在C和Linux中实现，我们现在只是在Golang中又实现它们。在实现这些优化时有很多的工作，但是这些工作与编程语言本身无关。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MY7pNlS8Yc_EQudZc-J%252F-MY7pS5OnZMu2BMlNCmd%252Fimage.png%3Falt%3Dmedia%26token%3D94666405-dfa9-493d-90f4-98b89d509a81&width=768&dpr=4&quality=100&sign=339c010b&sv=2)

今天[论文](https://pdos.csail.mit.edu/6.828/2020/readings/biscuit.pdf)的出发点就是了解用高级编程语言实现操作系统的收益和代价。所以我们将分两部分来评估，首先是收益，其次是代价。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MY7pUAMqWNkaNwqNNwv%252F-MYAGALs8KWF5yFTDi5O%252Fimage.png%3Falt%3Dmedia%26token%3D9fcc7004-17ca-4e0c-8a97-a83b7498b939&width=768&dpr=4&quality=100&sign=a7e7afeb&sv=2)

有关高级编程语言，我们要回答三个问题：

*   首先，我们有没有作弊？或许我们避免使用了所有Golang提供的高级编程语言中代价较高的功能。
    
*   其次，高级编程语言是否有简化Biscuit代码？
    
*   最后，高级编程语言是否能阻止前面提到的内核漏洞？
    

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MY7pUAMqWNkaNwqNNwv%252F-MYAIAgOu10Phw-Fnknc%252Fimage.png%3Falt%3Dmedia%26token%3D97046bf2-2ccf-48cb-9e1c-f0b1a1a1411a&width=768&dpr=4&quality=100&sign=df449ace&sv=2)

首先，我们有没有使用高级编程语言的特性？我们会对比一下Biscuit与其他两个大的Golang项目在使用语言特性上是否类似，这样我们才可以说我们的内核以类似的方式利用了相同的语言特性。这里我们使用了相同的静态分析工具来分析两个大的Golang项目，它们都有超过100万行代码，其中一个项目是Go runtime以及包含的所有包，另一个是一个叫做Moby的系统。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MY7pUAMqWNkaNwqNNwv%252F-MYAJUI_ufnzc6ZoCuqh%252Fimage.png%3Falt%3Dmedia%26token%3D5d63554f-0dcd-45a5-b1af-48794970545b&width=768&dpr=4&quality=100&sign=53b72d3c&sv=2)

之后我们画出了一些高级语言特性在每1000行代码中的使用量。图中X轴是语言特性：

*   allocation对应于new
    
*   maps就是hashtable
    
*   slice是动态数组
    
*   channel是同步的工具，如你所见我们用的很少，Go runtine和Moby也用的很少
    
*   很明显我们最喜欢的特性就是函数返回多个值
    
*   我们使用了Closure（闭包）
    
*   我们稍微使用了defer
    
*   我们使用了Interface
    
*   使用了Type assertion来以一种类型安全的方式将一个类型转换成另一个类型
    
*   同时我们也import了很多包，Biscuit内核是由很多个包构建出来的，而不是一个大的单一的程序
    

如你所见，有些特性Biscuit用的比Go runtime和moby更少，有些特性Biscuit用的更多，这里没有很明显的区别。所以从这张图中可以得出的主要结论是：Biscuit使用了Golang提供的高级编程语言特性，而不是为了得到好的性能而避开使用它们。

> 学生提问：你这里是怎么统计的？是不是使用了静态分析工具？
> 
> Frans教授：是的，这里使用的就是静态分析工具。通过写一个小程序利用静态分析工具来查看这些项目的每一行代码，并记录对应的特性是什么，这样就能统计这些特性的使用数量。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MY7pUAMqWNkaNwqNNwv%252F-MYAMia0mLJBcfc-4NSE%252Fimage.png%3Falt%3Dmedia%26token%3D811bd36f-efca-4b96-a7f1-9358fb39ba48&width=768&dpr=4&quality=100&sign=f97a2fbc&sv=2)

第二个问题有点主观，高级编程语言有没有简化Biscuit代码？笼统的说我认为有的，我这里会讨论一两个例子。

使用Garbage allocation是极好的，你可以回想XV6，当你调用exit时，有大量的结构化数据需要被释放回给内核，这样后面的进程才能使用。如果使用Garbage Collector这里的工作着实容易，Garbage Collector会完成这里的所有工作，你基本不用做任何事情。如果你从地址空间申请了一段内存，对应这段内存的VMA会自动被GC释放，所以这里可以简化代码。

如之前所说的，函数返回多个值对于代码风格很好。闭包很好，map也很好。XV6中很多地方通过线性扫描查找数据，但是如果你有map和hashtable作为可以直接使用的对象，那么你就不用线性扫描了。你可以直接使用map，runtime会高效地为你实现相应的功能。所以直观上的感受是，你可以得到更简单的代码。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MY7pUAMqWNkaNwqNNwv%252F-MYAUQuRMB3ldgPO8i57%252Fimage.png%3Falt%3Dmedia%26token%3D29109a95-ac73-4b96-8c68-47e2f0e87176&width=768&dpr=4&quality=100&sign=495fc16f&sv=2)

但是前面只是定性的评估，下面会介绍一些更具体的例子。当有大量的并发线程，且线程有共享的数据时，GC如何起作用的。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MY7pUAMqWNkaNwqNNwv%252F-MYAUY-VqGmoCDnym3Dn%252Fimage.png%3Falt%3Dmedia%26token%3D5cf159c5-669a-4274-84cb-8a1924cc6bf1&width=768&dpr=4&quality=100&sign=835db063&sv=2)

这里有个最简单的例子。假设你申请了一些动态的对象，比如说buffer，你fork一个线程来处理这个buffer，原线程也会处理同一个buffer。当两个线程都完成了工作，buffer需要被释放，这样内存才可以被后面的内核代码使用。这在C语言里面有点难协调，因为你需要有某种方式来决定buffer不再被使用。如果你使用GC，那么就没什么好决定的，因为当两个线程都处理完buffer之后，没有线程会指向那个buffer。GC会从线程栈开始追踪，并且在任何线程栈中都找不到buffer，因此GC会在稍后某个时间释放内存。所以在一个带GC的编程语言中，你完全不必考虑这个问题。

在C中你可以这样解决这个问题，为对象增加引用计数，引用计数需要被锁或者一些原子性操作保护，当引用计数到达0时，你可以释放内存。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MY7pUAMqWNkaNwqNNwv%252F-MYAW0s_ctMQWy26ftLF%252Fimage.png%3Falt%3Dmedia%26token%3D66a76e13-9fdf-4acb-8629-ffed782f51dd&width=768&dpr=4&quality=100&sign=c6172b10&sv=2)

实际中锁加上引用计数代价稍微有点高。如果你想要高性能，并且并发可以扩展到CPU核数，这可能会是个瓶颈，我们在后面介绍RCU的时候会看这部分。所以，如果你想要高性能，好的并发能力，人们倾向于不给读数据加锁。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MY7pUAMqWNkaNwqNNwv%252F-MYAXj2WlhZ7GXZSmP6e%252Fimage.png%3Falt%3Dmedia%26token%3D5982e1ad-3392-42e8-9856-9023a7bfc860&width=768&dpr=4&quality=100&sign=b6d7c0eb&sv=2)

在实际中，我们会使得读数据至少是不需要锁的，这样你就不需要付出额外的代价。上面是我们在Golang中的实现，我们有个get函数，它会读取并返回链表的头结点。这里就没有使用锁，而是使用了atomic_load，它会读取头结点，但是又不需要锁。后面的pop函数使用了锁。这种风格在Linux内核中非常常见，写数据需要加锁，读数据不用加锁。这里pop函数会从链表中弹出头结点，这样你就可以重用头结点对应的内存。在C中实现这种风格会有点困难，因为有可能当你释放头结点内存时，其他并发的线程正好读取到了头结点的指针。这样当你做完atomic_store，你不能释放指针内容，因为有可能有另一个线程的指针指向了这部分内容。如果你在这里释放了指针内容，你有可能会有use-after-free Bug。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MY7pUAMqWNkaNwqNNwv%252F-MYAacJjqoUxUtqvMI0K%252Fimage.png%3Falt%3Dmedia%26token%3D8e4d2e7a-524a-45a8-b6bb-216580ff662d&width=768&dpr=4&quality=100&sign=7916a31&sv=2)

我们在这门课程的最后一节课会看到，Linux内核对这个问题有一种非常聪明的解决办法，被称为Read-Copy-Update或者是RCU。它的工作就是推迟释放内存，直到确定指针不再被使用，并且它有一种非常聪明的方案来决定什么时候可以安全释放内存。但是这个方案有各种各样的限制，程序员需要在RCU关键区域内遵守各种规则。比如说你不能在RCU关键区域sleep，也不能切换线程。

所以尽管实际中Linux内核非常成功的使用了RCU，但是RCU还是有点容易出错，并且需要小心编程来使得它能正确工作。在带有GC的编程语言，例如Golang，这就不是问题了，因为GC会决定某个对象不再被使用，只有这时才释放它。所以现在对于编程人员来说没有限制了，所有的限制都被GC考虑了。这是一种带有GC的编程语言的明显优势。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MYAbAYCuNZb_gqyzfAB%252F-MYCnx-t0GZSwviWQZ_o%252Fimage.png%3Falt%3Dmedia%26token%3D7543ce71-5d16-49be-96b4-3ebdd7fd9569&width=768&dpr=4&quality=100&sign=12ef971d&sv=2)

接下来看看CVEs Bugs，这在前面提到过（注，20.1）。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MYAbAYCuNZb_gqyzfAB%252F-MYCoFzx20W9uxb1YVVc%252Fimage.png%3Falt%3Dmedia%26token%3Dfd9614d5-b89b-4e72-be72-30542d2250a1&width=768&dpr=4&quality=100&sign=ade2c762&sv=2)

我们手动的检查了所有的CVEs Bug，并尝试确定Golang是否修复了问题。

*   第一行代表我们不能弄清楚这些Bug的结果是什么，它会怎么展现，我们知道如何修复这些问题，但是我们不能确定Golang是否能避免这些问题。
    
*   有很多逻辑Bug，可以认为Golang会有与C相同的Bug，所以结果是相同的
    
*   接下来是40个memory-safety Bugs，包括了use-after-free，double-free，out-of-bound。其中8个直接消失了，因为GC考虑了内存释放，32个会产生panic，比如说数组越界。当然panic并不好，因为内核会崩溃，但是或许要比直接的安全漏洞更好。所以在这40个Bug中，高级编程语言有帮到我们。
    

以上就是使用高级编程语言实现内核的优势，接下来讨论一些代价，也就是High Level Language Tax。

[Previous20.6 Heap exhaustion solution](20.6-heap-exhaustion-solution.md)[Next20.8 Evaluation: HLL performance cost(1)](20.8-evaluation-hll-performance-cost-1.md)

Last updated 4 years ago

Was this helpful?