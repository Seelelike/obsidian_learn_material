> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mit-public-courses-cn-translatio.gitbook.io](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec20-kernels-and-hll-frans/20.2-gao-ji-bian-cheng-yu-yan-shi-xian-cao-zuo-xi-tong-de-you-lie-shi)

Copy

1.  [Lec20 Kernels and HLL (Frans)](/mit6-s081/lec20-kernels-and-hll-frans)

20.2 高级编程语言实现操作系统的优劣势
=====================

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MXz8FNyJnuZ-UAJ0kzV%252F-MXz8pXxXdF-3j0PnPbB%252Fimage.png%3Falt%3Dmedia%26token%3Deabf20c8-9e35-46dc-958e-1bfbefc70d8a&width=768&dpr=4&quality=100&sign=34bdb8bf&sv=2)

高级编程语言吸引人的一个原因是它提供了memory-safety，所以上一节中CVEs提到的所有Bugs，都将不再存在。要么当它们发生时程序运行时会检查数组是否越界，如果越界了就panic；要么高级编程语言不允许你写出引起Bug的代码，所以这些问题完全不可能出现。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MXz8FNyJnuZ-UAJ0kzV%252F-MXzAfjVqBVKyl5tYFBL%252Fimage.png%3Falt%3Dmedia%26token%3D0d4f57f6-c790-4b20-ab9d-c63117787575&width=768&dpr=4&quality=100&sign=412e8956&sv=2)

当然，高级编程语言还有一些其他的优点：

*   首先是Type safety，类型安全
    
*   通过GC实现了自动的内存管理，所以free更容易了，你都不用去考虑它，GC会为你完成所有的内存释放工作
    
*   对并发更友好
    
*   有更好的抽象，接口和类等面向对象的语法使得你可以写出更加模块化的代码
    

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MXz8FNyJnuZ-UAJ0kzV%252F-MXzC7DJuND-oaGX5qcJ%252Fimage.png%3Falt%3Dmedia%26token%3D6f3a5d15-5878-4000-bf28-e1af8b34c7ef&width=768&dpr=4&quality=100&sign=2c072d6f&sv=2)

高级编程语言有这么多优势，你不禁会想它有哪些缺点呢？为什么XV6或者Linux没有用Java，Golang，Python来写？

这里的原因是高级编程语言通常有更差的性能。高级编程语言通常都有一些额外的代价，这被称为High Level Language Tax。

*   比如说在索引一个数组元素时检查数据边界，比如说检查空指针，比如说类型转换。
    
*   除此之外，GC也不是没有代价的，需要花费一些时间来跟踪哪些对象可以被释放。
    

除了性能之外，高级编程语言与内核编程本身不兼容。

*   比如说高级编程语言没有直接访问内存的能力，因为这从原则上违反了Type safety。
    
*   高级编程语言不能集成汇编语言，而在内核中的一些场景你总是需要一些汇编程序，比如说两个线程的context switching，或者系统启动
    
*   编程语言本身支持的并发与内核需要的并发并不一致，比如我们在调度线程的时候，一个线程会将锁传递给另一个线程。一些并发管理模式在用户程序中不太常见，但是在内核中会出现。
    

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MXz8FNyJnuZ-UAJ0kzV%252F-MXzJFuXlDAFwETq3_la%252Fimage.png%3Falt%3Dmedia%26token%3Dcf1e41ac-84d3-4778-a057-1ded35c28ff3&width=768&dpr=4&quality=100&sign=5c2b9227&sv=2)

今天论文的目标是能够测量出高级编程语言的优劣势，并从safety，programmability和性能损失角度，探索使用高级编程语言而不是C语言实现内核的效果。

当然，为了做到这一点，你需要在一个产品级的内核上做实验，而不是在XV6上。XV6现在是由C语言写的很慢的内核，如果你用Golang也写了个很慢的内核，这不能说明C还是Golang更快，这只能说明XV6很慢。所以，你会想要在一个为高性能而设计的内核中完成这里的测量。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MXz8FNyJnuZ-UAJ0kzV%252F-MXzM0e8I47wTbcA2ur-%252Fimage.png%3Falt%3Dmedia%26token%3D1316fa55-7f68-4784-b1e6-7abf0d974f70&width=768&dpr=4&quality=100&sign=32b80425&sv=2)

很奇怪之前并没有一个论文完成了这里的测量。有很多论文研究了在用户程序中高级编程语言的优劣势，但是你知道的，内核与用户程序还是很不一样的，比如内核中需要有更小心的内存管理，内核中的并发或许会略有不同。所以，现在我们想要在内核中而不是用户程序中完成分析，而我们并没有找到之前的任何论文真正做了这个工作。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MXzMBDVZ4wNflk5sSH0%252F-MXzhaVZnrl1ZQjiwTAF%252Fimage.png%3Falt%3Dmedia%26token%3D08a8dcf3-e814-4c51-a54d-ae2bcca9bbe7&width=768&dpr=4&quality=100&sign=ea05c03b&sv=2)

之前的确有很多内核是用高级编程语言写的，这里有很长的历史，甚至可以回溯到最早的计算机中。但是最近的一些基于高级编程语言的内核并不是为了评估High Level Language Tax，而是为了探索新的内核设计和新的内核架构，所以这些内核并没有在保持结构相同的同时，直接对比C语言内核。只有保持系统结构相同，你才可以真正的关注语言本身，而不是一些其他的问题。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MXzMBDVZ4wNflk5sSH0%252F-MXzjNHugAdTokeq0wkU%252Fimage.png%3Falt%3Dmedia%26token%3D56970bd1-11cc-45bd-8a4f-a4f930b31f94&width=768&dpr=4&quality=100&sign=e30861eb&sv=2)

为什么没有很多论文做这样的对比测试？一个原因可能是这里的工作有点棘手。如果你想得到正确的结果，你需要与产品级别的C内核进行对比，例如Linux，Windows等等。同时，你也需要构建一个产品级别的内核。很明显，这对于一个小的团队来说很难，因为有许多许多的Linux开发人员日复一日做了许多许多的更新才创造了Linux，所以很难用高级编程语言实现同样的功能并构建同样的内核，所以我们这里会构建一个功能稍微少的系统内核。

![](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/~gitbook/image?url=https%3A%2F%2F1977542228-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHZoT2b_bcLghjAOPsJ%252F-MXzMBDVZ4wNflk5sSH0%252F-MXzl-st5xugrEYIp6ni%252Fimage.png%3Falt%3Dmedia%26token%3Db2c3c13c-3157-4b4d-a9fa-ef23da3d68f3&width=768&dpr=4&quality=100&sign=cfa37528&sv=2)

所以我们能做到的最好情况是：

*   用高级编程语言构建内核
    
*   保留与Linux中最重要的部分对等的功能
    
*   优化性能使得其与Linux基本接近，即使这里的功能与Linux并不完全一致，但是我们至少可以将它们拉到一个范围内
    
*   最后我们就可以测量高级编程语言的优劣
    

当然，这种方法的风险在于我们构建的内核与Linux还是略有不同，它不会与Linux完全一样，所以在得出结论时需要非常小心。这就是为什么不能对论文提出的问题（注，也就是应该使用什么样的编程语言实现操作系统）给出一个十分清晰的答案的原因。尽管如此，我们还是可以期望更深入的了解这个问题，而不是完全不知道它的内容。

以上就是论文的背景，以及为什么很少有人会做同样的工作的原因。

[Previous20.1 C语言实现操作系统的优劣势](20.1-c-yu-yan-shi-xian-cao-zuo-xi-tong-de-you-lie-shi.md)[Next20.3 高级编程语言选择 --- Golang](20.3-choose-golang.md)

Last updated 4 years ago

Was this helpful?