#### I/O与文件描述符

**文件描述符 (File Descriptor)**:
<!--ID: 1764664441630-->


- 这是操作系统为了管理已打开文件所创建的一个索引。每个进程都有一个“文件描述符表”。
- 标准输入 (Standard Input)、标准输出 (Standard Output)、标准错误 (Standard Error) 是三个特殊的文件描述符，编号分别为 **0**, **1**, **2**。



##### **fork和 exec系统调用来实现 I/O 重定向**

**`fork`系统调用**:
<!--ID: 1764664441633-->


- 作用是创建一个与当前进程（父进程）几乎完全一样的子进程。
- **关键特性**：子进程会**继承（复制）** 父进程的整个文件描述符表。这意味着在 `fork`的那一刻，子进程和父进程看到的是完全相同的打开文件集合。

父子进程对于文件描述符的关系如下所示：

父子进程有自己独立的文件描述符表，从进程的角度看，它们是不同的标识符，只是值恰好相同。父子进程的文件描述符是**指向同一内核文件表项的、各自独立的索引**。正是这个**共享的文件表项**，使得它们能够共享文件的偏移量和状态。

![image-20250924123843674](C:\Users\Suife\AppData\Roaming\Typora\typora-user-images\image-20250924123843674.png)

**`exec`系统调用**:

- 作用是**替换**当前进程正在运行的程序代码（例如，将 `shell`程序替换为 `cat`程序）。
- **关键特性**：虽然内存和程序代码被替换了，但**文件描述符表被保留了下来**。新程序（`cat`）会继承之前进程（子 shell）所有已打开的文件描述符。

1. **解析命令**：Shell 首先读懂你的命令 `cat < input.txt`，知道需要将 `input.txt`的内容作为 `cat`命令的输入。
2. **`fork`创建子进程**：Shell（父进程）调用 `fork`，创建一个和自己一模一样的子进程。
3. **子进程内重定向（关键步骤）**：
   - 子进程**关闭 (`close`)** 它的标准输入（文件描述符 0）。这只是关闭了子进程自己的描述符，对父进程（原来的 Shell）毫无影响。
   - 子进程**打开 (`open`)** 文件 `input.txt`。根据规则，系统会分配**当前可用的最小文件描述符**。由于刚才刚刚关闭了 0，所以 `input.txt`现在就被分配到了文件描述符 0 上。
   - 至此，在子进程中，**标准输入（0）已经不再指向终端，而是指向了 `input.txt`文件**。
4. **`exec`执行新程序**：子进程调用 `exec`来执行 `cat`程序。`cat`程序被加载进来，它继承了子进程的文件描述符表。因此，`cat`会自然而然地从它的文件描述符 0（即标准输入）读取数据，而此刻文件描述符 0 指向的是 `input.txt`，所以它就会读取文件内容并输出。
5. **父进程等待**：与此同时，父进程（原来的 Shell）会等待子进程执行完毕，然后继续显示命令提示符，准备接收下一条命令。父进程自己的标准输入（0）从未被改变过，所以它依然指向终端。



### 文件系统

```c
struct dirent {
    ushort inum;        // inode 号
    char name[DIRSIZ];   // 文件名 (通常14字节)
};
```

```c
struct stat {
    short type;         // 文件类型 (T_FILE, T_DIR)
    int dev;            // 设备号
    uint ino;           // inode号
    short nlink;        // 链接数
    uint size;          // 文件大小
};
```

对于目录`read()`获取 `dirent`结构

无论是文件还是目录都有inode号

#### 管道

定义：管道是操作系统提供的一种最基本的**进程间通信（IPC, Inter-Process Communication）** 机制。是一块小的**内核缓冲区**。通过一对**文件描述符（File Descriptors）** 暴露给进程。一个描述符用于写入(`p[1]`)、一个描述符用于读取(`p[0]`)写入一端的数据，可以从另一端按照**先进先出（FIFO）** 的顺序被读取。
<!--ID: 1764664441638-->


用法实例：

~~~c
int p[2];
char *argv[2];
argv[0] = "wc"; // 要执行的程序
argv[1] = 0;    // 参数数组结束标志

pipe(p); // 1. 创建管道，得到两个文件描述符 p[0]（读端） 和 p[1]（写端）

if(fork() == 0) { // 2. 创建子进程
    // 子进程代码块（负责读取管道并执行wc）
    close(0);     // 3. 关闭子进程的标准输入（文件描述符0）
    dup(p[0]);    // 4. 复制管道的读端p[0]到最低可用描述符（即刚关闭的0）
    close(p[0]);  // 5. 关闭原始的描述符p[0]（现在标准输入0已经指向管道了，p[0]可废弃）
    close(p[1]);  // 6. **关键**：关闭子进程不使用的写端。否则wc会永远等待更多数据。
    exec("/bin/wc", argv); // 7. 执行wc。wc会从标准输入（0），即管道读端，读取数据。
} else {
    // 父进程代码块（负责向管道写入数据）
    close(p[0]);  // 8. 关闭父进程不使用的读端。
    write(p[1], "hello world\n", 12); // 9. 向管道写端写入数据
    close(p[1]);  // 10. 写入完成后，关闭写端。
}
~~~

##### **管道的阻塞行为**

如果管道中**没有数据**，`read`操作会**等待（阻塞）**，直到：
<!--ID: 1764664441640-->


- 有数据写入。
- 或者**所有指向管道写端的文件描述符都被关闭**。

当上述第二种情况发生时（所有写端都被关闭），`read`会返回0，这就像读到了普通文件的末尾一样。这再次强调了**关闭未使用写端的重要性**。如果子进程不关闭自己的写端，即使父进程关闭了，管道中依然有一个写端（子进程自己的）是开着的，`wc`会永远等待下去。

##### shell如何实现管道命令

1. **解析命令**：Shell遇到 `grep fork sh.c | wc -l`时，识别出管道符 `|`。
2. **创建管道**：Shell进程（或一个辅助子进程）调用 `pipe()`创建一个管道。
3. **创建左右子进程**：
   - **Fork左进程**（`grep fork sh.c`）：这个进程会将其**标准输出（文件描述符1）** 重定向到管道的**写端**。然后执行 `grep`。`grep`的输出结果会全部写入管道。
   - **Fork右进程**（`wc -l`）：这个进程会将其**标准输入（文件描述符0）** 重定向到管道的**读端**（就像第一张图的例子）。然后执行 `wc`。`wc`会从管道中读取 `grep`产生的数据。
4. **等待完成**：Shell父进程等待左右两个子进程都结束后，继续显示提示符。
5. **处理复杂管道（递归）**：对于更复杂的命令如 `a | b | c`，Shell的处理是**递归**的。
   - 它首先将命令看作 `a | (b | c)`。
   - 先为 `b | c`再创建一个新的管道和两个新的子进程。
   - 最终形成一个**进程树**：内部节点是Shell创建的、用于协调管道的进程，叶子节点才是真正执行命令的进程（`a`, `b`, `c`）。
<!--ID: 1764664441643-->


##### 相较于临时文件的优势

``echo hello world | wc``与``echo hello world >/tmp/xyz; wc </tmp/xyz``可实现同样的功能。
<!--ID: 1764664441646-->


优势

- **自动清理**：管道会自动清理自身；使用文件重定向时，shell 在完成操作后必须小心地删除/tmp/xyz。
- **支持任意长的数据流**：管道可以传递任意长度的数据流，而文件重定向则需要足够的磁盘空间来存储所有数据。
- **允许并行执行**：管道允许并行执行管道阶段，而文件方法则需要第一个程序完成后再开始第二个程序。
- **高效的阻塞式语义**：
  - **管道**：其读写操作默认是**阻塞**的。如果读一个空管道，读取进程会自动休眠，直到有数据到来；如果写一个满管道，写入进程会休眠，直到有空间。这种由内核调度的**同步机制非常高效**。
  - **临时文件**：文件读写通常是非阻塞的，或者需要程序自己实现复杂的轮询或锁机制来协调两个进程，这在效率和编程复杂度上都不如管道。

#### 文件系统

##### 核心概念

1. **文件名 (Filename) vs. 文件本身 (Inode)**
   - 这是一个至关重要的抽象。你看到的文件名（如 `/dir/file`）**并不是文件本身**。
   - 文件真正的数据、元数据（metadata）存储在一个叫做 **inode**（索引节点） 的数据结构里。
   - 可以把 **inode** 想象成文件的“身份证”或“核心档案”，而**文件名**只是一个“方便人类呼叫的别名”。
2. **链接 (Link)**
   - 正因为“名称”和“实体”是分离的，所以**同一个 inode（即同一个文件）可以有多个不同的文件名**。
   - 这些不同的文件名就叫做 **链接**。每个链接实际上就是目录里的一个条目，这个条目包含了一个文件名和它指向的 inode 编号。
3. **Inode 存储的内容**
   - 一个文件的 inode 中存储了关于该文件的所有**元信息**，例如：
     - **文件类型**：是普通文件、目录，还是设备文件？（这就是系统如何知道 `/console`是个特殊设备的方法）
     - **文件权限**（rwx）。
     - **文件大小**。
     - **文件数据在磁盘上的存储位置**（指针）。
     - **链接计数**：有多少个文件名指向这个 inode。
<!--ID: 1764664441648-->


- **`mkdir`** 和 **`open`** 会创建新的 **inode**（类型分别为目录和普通文件），并在指定的目录中创建一个**链接**（名称条目）指向它。
- **`mknod`** 也会创建一个新的 **inode**（类型为设备文件），并在目录中创建**链接**。这个 inode 里不存储文件数据，而是存储了**主次设备号**，从而与内核设备关联起来。

##### mknod创建设备文件

- **功能**：创建一个**特殊文件**，该文件不对应磁盘上的数据块，而是对应一个**内核设备**（如终端、打印机、磁盘等）。
- **关键参数**：`mknod`需要两个额外的参数来唯一标识目标设备：
  - **主设备号 (Major device number)**：用于标识**设备类型**（例如，是哪种磁盘驱动或终端驱动）。
  - **次设备号 (Minor device number)**：用于标识**同类型设备中的具体实例**（例如，是哪一块具体的磁盘或哪一个具体的终端）。
- **示例**：`mknod("/console", 1, 1);`
  - 创建一个名为 `/console`的文件。
  - 它指向主设备号为1，次设备号为1的内核设备。在UNIX传统中，这通常代表系统的**控制台设备**。
- **工作原理**：当进程后续对这个设备文件进行 `read`或 `write`操作时，内核会**拦截这些请求**，并将它们**重定向**给相应设备驱动提供的实现函数，而不是交给普通的文件系统处理。这就实现了**“一切皆文件”** 的抽象——读写设备就像读写普通文件一样。
<!--ID: 1764664441651-->




#### ecall

用户的应用程序执行系统调用的唯一方法就是通过 `ecall`指令
<!--ID: 1764664441653-->


**通过硬件强制隔离用户与内核，并将所有交互集中到一个可控的入口（`ecall`）**

为什么需要ecall

​		现代 CPU（如 RISC-V）通过特权级（Privilege Levels）实现硬件级的安全隔离。用户程序运行在最低特权级（用户态，U-mode），无权直接执行特权指令（如访问硬件设备、修改页表等）。而操作系统内核运行在高特权级（监管态，S-mode或机器态，M-mode），拥有完全控制权。若用户程序能直接调用内核代码或访问硬件，恶意程序可能破坏系统稳定性。`ecall`的作用类似于一道“安检门”，所有请求必须通过它**标准化、受控地**进入内核。

ecall如何发挥作用

当用户程序执行 `ecall`时，CPU 会触发以下硬件行为：

1. **特权级提升**：CPU 从用户态（U-mode）切换到监管态（S-mode）。
2. **保存现场**：将当前程序计数器（PC）、状态寄存器（如 `mstatus`）等关键上下文保存到特定寄存器（如 `mepc`）。
3. **跳转到陷阱处理程序**：PC 被设置为预先定义好的陷阱处理程序（Trap Handler）入口地址（由 `stvec`寄存器指定），开始执行内核代码。
4. **参数传递**：用户程序通过约定好的寄存器（如 RISC-V 的 `a0-a7`）传递系统调用号和参数，内核通过 `a0`返回结果。



#### 执行系统函数

参考[xv6（RISC-V）操作系统源码分析第四节——陷阱_panic xv6-CSDN博客](https://blog.csdn.net/MCQSW/article/details/135196562)
<!--ID: 1764664441655-->


`trace(atoi(argv[1]))`被执行。这个用户态函数实际上是一个由汇编代码实现的“存根”

`user/usys.pl`脚本。当执行 `make`编译时，这个脚本会为每个系统调用生成对应的汇编存根代码。

~~~
.global trace
trace:
    li a7, SYS_trace   # 将系统调用号加载到a7寄存器
    ecall              # 执行环境调用指令，陷入内核
    ret                # 从系统调用返回
    
这里存入 a7寄存器的 SYS_trace，是一个在 kernel/syscall.h中定义的系统调用编号（例如 #define SYS_trace 22），而不是 sys_trace函数的地址。内核通过这个编号来识别用户请求的是哪个系统调用
~~~

`ecall`指令使从用户态（U-mode）陷入到内核态（S-mode）。

当用户程序执行 `ecall`指令后，CPU 硬件会自动将程序计数器（PC）设置为 `stvec`寄存器指向的地址，也就是 `uservec`的起始处。此时，CPU 已切换到内核态（S-mode），但**使用的仍然是用户页表**。`uservec`的首要任务就是在不破坏用户环境的前提下，安全地切换到内核环境。

~~~
交换了 a0和 sscratch寄存器的值。在进入 uservec之前，sscratch寄存器已经被内核预先设置为当前进程的 trapframe 页的虚拟地址。交换后，a0寄存器就持有了 trapframe 的地址，而用户程序原本的 a0值（可能是系统调用的参数）则被暂时安全地存放在 sscratch中
csrrw a0, sscratch, a0

将除了 a0之外的所有用户寄存器（ra, sp, gp, ..., t6）的值，保存到以 a0为基地址的 trapframe 页中相应的偏移位置上
sd ra, 40(a0)
sd sp, 48(a0)
...

保存用户 a0 寄存器
csrr t0, sscratch
sd t0, 112(a0)

# restore kernel stack pointer from p->trapframe->kernel_sp
# 加载内核栈指针到 sp寄存器。每个进程都有自己独立的内核栈
ld sp, 8(a0)
<!--ID: 1764664441657-->


# 加载当前 CPU 的硬件线程 ID (hartid)到 tp寄存器
# make tp hold the current hartid, from p->trapframe->kernel_hartid
ld tp, 32(a0)
<!--ID: 1764664441659-->


# 加载sertrap函数的地址到t0寄存器。usertrap是内核中处理 trap 的 C 函数。
# load the address of usertrap(), p->trapframe->kernel_trap
ld t0, 16(a0)
<!--ID: 1764664441661-->


# 从 trapframe 中加载内核页表的地址到 t1，然后将其写入 satp寄存器，完成页表切换
# restore kernel page table from p->trapframe->kernel_satp
ld t1, 0(a0)
csrw satp, t1
<!--ID: 1764664441663-->

# 切换页表后，必须使用此指令清空 TLB（快表），确保后续地址翻译使用新的页表
sfence.vma zero, zero
<!--ID: 1764664441666-->


# a0 is no longer valid, since the kernel page
# table does not specially map p->tf.

# jump to usertrap(), which does not return
jr t0
~~~
<!--ID: 1764664441668-->


``uservec``保存现场然后跳转到``usertrap``



### trap

共有三种事件导致 CPU 搁置普通指令执行并强制将控制权转移到处理该事件的特殊代码，使用 **trap** 作为这些情况的通用术语。
<!--ID: 1764664441669-->


- 系统调用，当用户程序执行 ecall 指令以要求内核为其执行某些操作时。

- *exception* ：指令（用户或内核）执行非法操作，例如除以零或使用无效的虚拟

  地址。

- 设备 *interrupt* ，当设备发出需要注意的信号时，例如当磁盘硬件完成

  读取或写入请求时。

#### 重要寄存器

- stvec：内核将其 *trap*处理程序的地址写入此处；RISC-V 跳转到 stvec 中的地址
<!--ID: 1764664441671-->


  来处理 *trap*。

- sepc：发生 trap 时 CPU 会自动将当前指令地址存入 `sepc`当从 trap 返回（执行 `sret` 指令）时，CPU 会把 `sepc` 的值恢复到 `pc`，从而让程序“接着刚才的地方”继续执行。内核可修改`sepc`，以实现跳过出错指令或重新执行等操作。

- scause：RISC-V 在此处放置一个数字来描述 *trap*的原因。8（系统调用）、5（访问无效地址）、9（外部中断）

- sscratch：提供一个“临时寄存器”给 trap 处理程序使用。因为刚进入 trap 时还没保存通用寄存器，使用 `sscratch` 可以避免破坏用户程序状态。

- sstatus：sstatus 中的 SIE 位控制是否启用设备中断。如果内核清除 SIE，RISCV 将推迟设备中断，直到内核设置 SIE。SPP 位指示 *trap*是来自用户模式还是管理模式，并控制 sret 返回的模式。

#### 进入trap

当需要强制 *trap*时，RISC-V 硬件会对所有 *trap*类型（定时器中断除外）执行以下操作：
<!--ID: 1764664441673-->


1. 如果 *trap*是设备中断，并且 sstatus SIE 位清零，则不要执行以下任何操作。

2. 通过清除 sstatus 中的 SIE 位来禁用中断。

3. 将 pc 复制到 sepc 。

4. 将当前模式（用户或管理员）保存在 sstatus 的 SPP 位中。

5. 设置 scause 以反映 *trap*的原因。

6. 将模式设置为主管。

7. 将 stvec 复制到 pc 。

8. 在新的 pc 处开始执行。

#### 用户空间trap

##### 进入trap

具体操作如下：

- 从用户模式提升到监督者模式
- 将当前指令地址或下一条指令地址放入sepc中保存
- 将stvec中保存的trampoline页的地址放入PC中，准备进入
- 将当前的陷阱原因记录在scause寄存器中
- 将当前模式保存在sstatus的SPP位中，并清空sstatus的SIE位来关闭设备中断，而之前的
- SIE位会保存在SPIE位
- 更新stval寄存器的值，使其指向异常的地址
- 复制PC到sepc。
- 将stvec复制到PC。
- 从新PC开始执行。

**现在，PC被设置为指向uservec，因为stvec指向uservec。**

`用户空间的trap的处理路径是：uservec--->usertrap--->usertrapret--->userret`

##### uservec

RISC-V 硬件在trap过程中不切换页表，所以用户页表必须包含uservec的映射，即stvec指向trap处理程序的地址。而从用户页表切换到内核页表这一任务就归到了uservec上。uservec会切换satp，使其指向内核页表。为了在切换后继续执行指令，uservec必须被映射到内核页表与用户页表相同的地址。
userver与userret位于**trampoline页**
<!--ID: 1764664441676-->


当uservec启动时，所有32个寄存器会保存被中断代码所拥有的值。 uservec会执行csrrw指令将寄存器a0与sscratch的内容互换。这样一来，当前用户代码的a0被保存至sscratch中，uservec可以安心使用a0寄存器。而a0寄存器包含了内核之前存放在sscratch中的值。

uservec接着会保存用户寄存器。在进入用户空间时，内核先向sscratch中写入指向该进程的trapframe的地址。trapframe用来保存所有用户寄存器。此时satp仍然指向用户页表，a0寄存器中存放的是指向当前进程的trapframe的地址。

当创建每个进程时，xv6为进程的trapframe分配一页内存，并将它映射到用户虚拟地址TRAPFRAME中，即TRAMPOLINE下面。这样进程的p->trapframe也指向trapframe，不过是指向物理地址，如此一来，内核也可以通过内核页表来使用它。

所以，此时的a0指向当前进程的trapframe，uservec将在trapframe中保存全部的寄存器，包括从sscratch中读取a0来保存a0。

trapframe包含指向当前进程的内核栈、当前CPU的硬件线程ID、usertrap的地址和内核页表的地址。uservec将这些值设置到相应的寄存器中，并通过写入satp来切换至内核页表，同时刷新TLB。

最后，uservec调用usertrap。

##### usertrap

usertrap的作用——**确定trap的处理方式**
<!--ID: 1764664441678-->


usertrap的作用就是确定trap的类型，然后处理它，最后返回。 
usertrap首先改变stvec，这样在内核中发生的trap会由kernelvec处理。同时，usertrap会保存sepc，此时的sepc存储着发生trap的指令的地址（用户PC），防止发生进程切换导致sepc被覆盖。 

- 若trap是系统调用，syscall会处理它。

- 若是设备中断，devintr会处理它。

- 若是异常，内核会杀死异常进程。

usertrap会将用户PC加4，来生成发生trap的指令的下一条指令的地址。usertrap检查进程是否被杀死或应该让出CPU（若这个trap是一个定时器中断）来决定是否退出。

##### usertrapret

usertrapret的作用——**为trap的返回准备条件**
<!--ID: 1764664441680-->


设置RISC-V 控制寄存器，为以后用户空间trap做准备。这包括设置stvec指向uservec，准备uservec所依赖的trapframe字段，并将sepc设置为先前保存的用户程序计数器PC。最后，usertrapret在用户页表和内核页表中映射的trampoline页上调用userret，因为userret中的汇编代码会切换页表。

usertrapret对userret的调用传递了参数a0与a1，a0指向TRAPFRAME，a1指向用户进程页表，userret将satp切换到进程的用户页表。

当然，usertrapret会关中断，直到执行sret前，都不会响应中断。

再次强调，在用户页表和内核页表中，trampoline页被映射在相同的虚拟地址上，这也是允许uservec在改变satp后继续执行的原因。

##### userret

userret的作用——**返回**
<!--ID: 1764664441682-->


userret将trapframe中保存的用户的a0复制到sscratch中，为以后与TRAPFRAME交换做准备。从这时开始，userret能使用的数据只有寄存器中的内容和trapframe中的内容。

接着，userret从trapframe中恢复保存的用户寄存器，对a0和sscratch做最后的交换，恢复用户a0并保存TRAPFRAME，为下一次trap做准备，并使用sret返回用户空间。

#### 内核空间trap

xv6根据用户代码在执行还是内核代码在执行，会对CPU陷阱寄存器进行不同的配置。
<!--ID: 1764664441684-->


当内核代码在CPU上运行时，内核将stvec指向kernelvec（一个汇编程序）上的汇编代码。kernelvec会使用satp寄存器切换至内核页表，并引用有效内核的堆栈指针。kernel会保存所有寄存器至中断内核线程的堆栈上，因为寄存器值属于该线程，这是合理的。

kernelvec在保存寄存器后跳转到kerneltrap。kerneltrap会处理两种陷阱——设备中断和异常。

设备中断：kerneltrap调用devintr处理
异常：调用panic停止执行，因为发生在xv6内核中的异常一定是严重错误。xv6对异常的响应结果是固定的。发生在用户空间的异常，内核会杀死故障进程。发生在内核空间的异常，内核会panic。
如果是由于计时器中断而调用kerneltrap，并且当前进程的内核线程正在执行，kerneltrap会调用yield让出CPU，允许其他进程执行。在某个时刻，一个线程退出后让上述线程及其kerneltrap恢复。

当kerneltrap的工作完成时，它需要返回到被中断的代码。因为yield可能破坏保存的sepc和在sstatus中保存的之前的模式。kerneltrap在启动时保存它们。它现在恢复那些控制寄存器并返回到kernelvec。kernelvec从堆栈恢复哪些保存的寄存器并执行sret，sret将sepc复制到PC并恢复中断的内核代码。



### Page fault

**Page fault（缺页异常）\**不只是“出错”：现代内核用它做聪明的“延后工作”和“按需复制”，比如\**写时复制（COW）**、**懒分配**、**按需调页（demand paging）**，以及**分页到磁盘（swap）**等，从而把启动更快、内存更省、系统更稳这几件事同时做好。
<!--ID: 1764664441685-->


#### 定义

当 CPU 访问一个虚拟地址而**无法按当前页表权限/映射完成**时，就会触发 page fault。
 在 **RISC-V** 上常见三类：
<!--ID: 1764664441687-->


- **Load page fault**：读址失败
- **Store page fault**：写址失败
- **Instruction page fault**：取指失败
   寄存器：`scause` 指示类型，`stval` 给出有问题的地址。

触发原因通常有三类：

1. 该虚拟地址**根本没映射**（PTE 不存在或 `PTE_V`=0）
2. **权限不满足**（例如写一个只读页，`PTE_W`=0）
3. **用户/内核界限**不满足（如 `PTE_U` 不允许用户访问）

#### COW

普通 `fork`（如 xv6 的 `uvmcopy`）会**立即为子进程分配并拷贝**父进程的所有用户内存，**成本高**且经常**白拷贝**（很多页随后会被 `exec` 直接丢弃）。
<!--ID: 1764664441688-->


##### 核心思路

1. **父/子共享**所有物理页，但**都映射为只读**（清 `PTE_W`）。
2. 父或子**第一次写**某页时 → **触发写页故障（store fault）**。
3. **陷入处理程序**：
   - 若该物理页被多个地址空间共享：**分配新物理页**，把老页内容复制过去；
   - 更新**故障进程**的 PTE 指向**新页**并**设为可写**；
   - **从故障指令重试**，这次就能写成功。
4. 若判断**该物理页只被当前进程引用**（见下），**可直接升级权限为可写**，**无需复制**（重要优化）。
<!--ID: 1764664441690-->


##### 必要的“台账”（补充解释）

要知道“这页是否被别人也在用”，内核需要给每个物理页维护一个**引用计数**（或共享计数）。
<!--ID: 1764664441692-->


- `fork` 后：计数增加；
- 发生写时复制：为新页设计数=1，旧页计数减一；
- `exec`/`exit`：相应减少计数；
- 计数归零 → 可安全释放该物理页。

> **小结**：COW 把“全量复制”延迟到“首次写入”，大多数情况下**根本不会写到那么多页**，所以总体更快、更省内存，而且**对应用透明**。

#### Lazy allocation

按需申请，延后兑现
<!--ID: 1764664441694-->


- 应用调用 `sbrk` 扩大地址空间时，内核**只记下大小**，**不立刻分配物理页，不建 PTE**。
- 当程序**第一次访问**这些新地址时触发 page fault：
  - 内核**那一刻**分配物理页，**建 PTE**，然后返回用户态继续执行。
- **好处**：
  - 应用经常“多要少用”，**未使用的页完全不做工**；
  - 巨量扩容（如一次申请 1GiB）不再瞬时分配/清零 262,144 个 4KiB 页，成本被**摊平到访问时**。
- **代价**：
  - 首次访问会多一次**内核/用户切换**开销。
  - 可用**批量分配**或**专门优化陷入路径**降低多次 page fault 的损耗。

#### Demand paging

启动更快，读到再加载
<!--ID: 1764664441695-->


- 传统 `exec` 会**急切**把程序的文本段/数据段**一次性读入内存**。
- **按需调页**：只建立虚拟地址空间与文件的**延迟映射**，把 PTE 标成**无效**；
- 运行时遇到未加载的页 → **page fault**：
  - 内核**从磁盘把该页读入内存**，修正 PTE，再继续执行。
- **效果**：大应用**启动更快**，用户更快看到响应。

#### Paging to disk

当 RAM 不够用
<!--ID: 1764664441697-->


- 只有一部分用户页留在 RAM，其余放到**磁盘交换区**。
- 被换出的页对应的 PTE 会被**标无效**或**标记为在交换区**。
- 当应用再次访问该页 → **page fault**：
  - 内核**找一页空闲 RAM**（必要时先**淘汰**别的页），
  - **把磁盘上的页读回 RAM**，更新 PTE 后继续执行。
- **关键问题：如果没有空闲 RAM**
  - 先**选择牺牲页（evict）**写回磁盘，标记其 PTE 无效，再把目标页读入。
- **性能要点**：
  - 交换（I/O）昂贵，因此要依赖应用的**局部性（locality）**：常用的那一小撮页能留在 RAM，换入换出才不会频繁抖动（thrash）。

